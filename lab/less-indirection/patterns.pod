=head1 Introduction

This document intends to be an exhaustive catalog of runtime object
use and interaction patterns.  It aims to be generally applicable, but
it also recommends "best of breed" patterns for a particular object
framework design called I<the framework>.

Any usable object framework must support every useful design pattern,
either through core mechanisms or by extension.  While the framework
strives to make common things easy, it must not preclude useful
patterns.  One reason for cataloging as many patterns as possible is
to ensure that all possible patterns are considered.

=head1 Object Categories

=head2 Helpers

Helper objects are created and owned by another object to perform one
or more tasks.  Most objects are helpers.

	sub do_something {
		my ($self, $args) = @_;
		$self->{helper} = POE::Helper->new();
	}

Helpers often have synchronous-looking interfaces, but they may behave
asynchronously if appropriate.  Synchronous methods may trigger
asynchronous processes on behalf of the caller.

I<Todo:> Is this confusing?  How can the framework clarify when a
method is synchronous or asynchronous?  Do we need a naming convention
to differentiate between synchronous and asynchronous methods?

=head2 Services

Services are stand-alone objects that handle asynchronous events.
They may be stored in a widely-scoped registry or namespace.  They may
be singletons that respond to class methods.  They may be visible to
remote processes or objects.

I<Todo:> Services have not been considered in great depth.  The
framework must be capable of cleanly supporting services, otherwise
its design will need to be changed.  One purpose of documenting the
framework in detail is to examine the interactions between concepts
and explore its extensibly before too much code is written.

=head1 Object Management

Perl takes care of low-level memory management, but the language still
requires programs to manage objects.  Perl programs manage objects by
holding references to them.  Perl considers unreferenced objects to be
unused, and it destroy them and reclaim their memory.  It's common for
an object reference to be stored somewhere until the object stops
being useful.

	my $object = Object->new();
	$object->do_stuff();
	$object = undef;

=head2 Object Scope

=head3 Within One Object

An object is created by another object, and it is stored within its
creator for use by its creator.  The object is generally used directly
only by its parent.  The framework focuses on this use pattern, but it
should support the others.

	package Object;

	sub do_something {
		my $self = shift;
		$self->{another_object} = AnotherObject->new();
	}

=head3 Within Multiple Objects

An object is created and passed among (or exposed to) two or more
objects.  Use of the object is generally not coordinated, so the
object must handle being called at odd times.  Perl usually prevents
the object from being re-entered however.

	package ObjectFactory;

	sub create {
		return Object->new(@stuff);
	}

I<Todo:> The framework doesn't support this model well.  How can it be
improved?

=head3 Within a Namespace

An object is created and stored in a namespace which publishes it to
one or more other objects.  Users tend to look up these objects as
needed rather than hold onto them.

	package Something;

	my %namespace;

	sub do_something {
		my ($self, $name) = @_;
		$namespace{$name} = AnotherObject->new();
	}

I<Todo:> Formalize namespaces and perhaps distributed objects along
the way.

=head2 Object Relationships

Perl's concept of ownership is tightly coupled to object references.
Whatever holds a reference to an object owns that object.  An object
may have multiple owners in Perl, depending on what and how many
things refer to the object.  Object references may be copied and
passed around without restriction.

I<Todo:> Can we co-opt Perl's ownership, or must we really have our
own separate concept?  We would need a way to know which objects and
classes held references to other objects.

The framework manages its own concept of ownership based on the idea
that child objects are created to perform work.  Objects' creators are
their default owners.  The framework's usefulness would be limited if
an object couldn't be given to a new owner.

Interaction is common between an object and its owner.  The framework
recognizes this and implicitly tracks these parent-child relationships
among all framework-based objects.  At any moment, the framework
should know

=over 2

=item * the currently active object,

=item * every object's creator (or parent or owner),

=item * and every object's child objects.

=back

Child objects must know which objects created them, so they know which
objects to help.  Services may need to know which objects made
requests so they may send responses to the right ones.  Parent objects
may pass $self to their children, but doing so and the mechanisms of
storing the parent are a lot of redundant work.  It would be more
convenient for everything to implicitly know which object is currently
active, so the framework tries to accomplish this in its base classes.

There are at least two ways to track the current object.  Examine the
call stack via caller() in package DB, or have the framework call
everything.  The former is more convenient from the user's point of
view, but it's harder to implement reliably.  The latter imposes more
restrictions on application design, but POE and POE::Stage have shown
that it's more reliable.

I<Todo:> Nick Perez suggests a couple possibilities.  He writes
(paraphrased): It seems like there should be an easier way to
determine your immediate parent without having to walk the caller
stack.  Maybe using a decorator that injects the current $self.  A
scope hack.  You could also try using something rjbs has been working
on: MRO::Magic.  If you want to know more about custom delarators,
take a look at Devel::Declare and MooseX::Declare.  A simple C<<
parent SomeObject->new() >> could deliver what you want.  It is a
little magicky, but it might inject $self a lot easier than walking
the caller stack.

All objects are I<not> created equal.  Basic, entirely local and
synchronous objects need not be tracked at all.

=head2 Explicitly Manged Objects

Most object management is explicit.  An object is created, and its
creator stores a reference to it somewhere.  The object's creator uses
the reference to invoke, access or alter the object.  When the object
is no longer needed, its creator releases its reference, and it
destructs.

	sub some_method {
		my $self = shift();
		$self->{sub_object} = Object->new();
		$self->{sub_object}->do_something();
	}

	sub sometime_later {
		my $self = shift();
		delete $self->{sub_object};
	}

=head2 Implicitly Managed Objects

Implicit object management is a concept introduced by the framework,
so it will be described in terms of what the framework will do.

Objects may be implicitly managed by the framework on behalf of their
owners.  This simplifies management and cleanup of objects that aren't
accessed between the time of creation and destruction.  As a corolary,
the framework also provides some introspective methods to access
implicitly managed objects in cases where minimal access is required.

The framework internally tracks objects and their creators in a tree
where creators are parent nodes for the objects they create.  Objects
may be described as I<parents> or I<children> when talking about them
in these roles.  Parents may sometimes be called I<owners> when it
makes sense to consider ownership semantics.

Implicitly managed objects are usually self-destructing as well.
I<Todo:> Link to section on self destruction.

Since this is Perl, the framework provides more than one way to
implicitly manage objects.

=head3 Implicit Management on Request

Objects are implicitly managed by detaching them from their parents.
A parent object may detach a child from itself, allowing the object to
be implicitly managed by the framework.

	sub create_configure_and_detach_an_object {
		my $object = Object->new();
		$object->timeout(60);
		$object->detach();
	}

I<Todo:> Is detach() a good name for this?

I<Todo:> Should the child be asked to detach itself, or should the
parent be told to detach its child?  It can't be both, as detach() is
implemented in the same base class used by the parent and its
children.  A beter name might clear up the semantics.

=head3 Implicit Management During Creation

Often an object will be sufficiently configured during construction.
The framework supplies a separate constructor, spawn(), that
implicitly detaches the child from its creator.  This object will be
implicitly managed by its creator.

	sub spawn_an_object {
		my $self = shift(); # unused
		Object->spawn();
	}

spawn() itself might be written in terms of new() and detach().  Note
that spawn() doesn't return a reference to the new object.  An
application should decide which semantics are needed and choose the
right constructor for the job.

	sub Object::spawn {
		my ($class, @args) = @_;
		my $new_object = $class->new(@args);
		$new_object->detach();
		undef;
	}

=head3 Inspecting Implicitly Managed Objects

Implicitly managed objects are generally hidden, but the framework
allows them to be examined and manipulated with some effort.

It is probably a sign that explicit management is the better design if
an application finds itself overly burdened by inspecting implicitly
managed objects.

The framework's base object class provides methods that return an
object's implicitly owned children.

	sub owner_method {
		my $self = shift();
		my @children = $self->child_objects();
		# ... do something ...
	}

A parent object may limit inspection by object class and/or role.

	sub shutdown_my_resolvers {
		my $self = shift();
		foreach my $resolver ($self->child_objects(role => "resolver")) {
			$resolver->shutdown();
		}
	}

	sub cancel_my_delays {
		my $self = shift();
		foreach my $delay ($self->child_objects(class => "Delay")) {
			$delay->cancel();
		}
	}

Retrieved objects may merely be counted.  For example, to refill a
worker pool.

	sub refill_resolver_pool {
		my $self = shift();
		while ($self->child_objects(role => "resolver") < 10) {
			Resolver->new(
				role => "resolver",
				host => shift(@hosts_to_resolve),
				type => "A",
			);
		}
	}

=head2 Transferring Object Ownership

Ownership conveys certain benefits.  For example, the framework
provides convenience methods for object communication between a child
and its parent.  Implicit object management is also tightly coupled to
the concept of object ownership.

I<Todo:> The single owner model implies certain restrictions to
parental benefits.  Are these restrictions limiting?  Can they be
lifted through a different ownership mechanism?

The exact mechanism for object movement isn't firm yet, but it may be
as simple as calling a method from the new owner.  The object's new
parent would call the method on the object being claimed.  This
take_object() method might be implemented on the parent.

	sub take_object {
		my ($self, $object) = @_;
		$object->move();
	}

Transferrence failure should be reported with an exception, which
would guarantee that the program fails close to the actual problem.

Different owners may implement different interfaces for handling a
child's responses.  It should be possible to attach a moving object to
its new parent's interface regardless of the differences.  The
proposed move() method may take "role" and response parameters to
adjust how the child interacts with its new owner.  Here the moved
object is assigned a new role and a specific failure method.

	sub take_object {
		my ($self, $object) = @_;
		$object->move(
			role       => "resolver",
			on_failure => "special_failure_method",
		);
	}

A factory may now create new objects on behalf of other objects, then
ask new owners to take them.

	sub object_factory {
		my ($self, $recipient) = @_;
		$recipient->take_object( Object->new() );
	}

Role and callback validation should happen at new(), spawn() and
move() time.  These methods can ensure that an object's owner can
handle all required responses.

I<Todo:> This level of validation requires some introspection into the
parent class and the child's command/response interface.  Moose or
Class::MOP can provide the parent class introspection, but something
new must be added to query the child's request/response interface.

I<Todo:> Explore the implications of role and callback validation
timing.  For example, it means that required response handlers must be
known before child objects are created, spawned or moved.  What
restrictions does this impose on object use patterns?  I have a strong
feeling that I'm overlooking an important side effect.

=head2 Object Destruction

=head3 Automatic Self-Destruction

Objects may automatically self-destruct when they are done with their
work.  Self-destruction can be thwarted by posession of additional
object references, so self-management or careful attention to object
lifespans is required.

Here a name resolver is spawned to resolve a single host name.  It
will self-destruct once its response---either success or failure---is
delivered.

	Resolver->spawn(
		role => "resolver",
		host => "poe.perl.org",
		type => "A",
	);

	sub on_resolver_success {
		# handle successful response
	}

	sub on_resolver_failure {
		# handle error response
	}

Applications may also use weak references to manipulate self-managed
objects.  Applications must remember to occasionally clean up defunct
weak refereces, or they may encounter memory leaks.  A better
alternative may be to inspect self-managed objects when needed.
I<Todo:> Link.

=head3 Object Destructs Upon Request

Destruction upon request is useful for canceling tasks before they
complete.  Explicitly managed objects may be destroyed by releasing
their object references.

	sub cancel_sub_object {
		my $self = shift();
		delete $self->{sub_object};
	}

Explicit shutdown() methods are recommended, especially if shutdown is
a complex process that can't be completed within a single destructor
call.

	sub shutdown_sub_object {
		my $self = shift();
		$self->{sub_object}->shutdown();
	}

	sub on_subobject_destruction {
		my $self = shift;
		delete $self->{sub_object};
	}

Implicit management may make explicit shutdown easier since child
objects are automatically cleaned up.

=head3 Object Never Destructs

Objects that are used for the lifespan of an application are never
destroyed.  This pattern is common, and it often causes edge cases in
object managers.

=head1 Task Lifespan

=head2 Task Commencement During Instantiation

Objects creation and task commencement can be tightly coupled.  Object
constructors can bootstrap the work to be performed.  This is a common
pattern for helper objects.

	my $resolver = Resolver->new(
		role => "resolver",
		host => "poe.perl.org",
		type => "A",
	);

	sub on_resolver_success {
		# continue with successful path
	}

	sub on_resolver_failure {
		# handle error
	}

=head2 Task Commencement Upon Request

Task commencement may be delayed until an explicit request is made.
This decouples the work from the object's constructor.  This pattern
is useful for lazy objects and to allow task customization by
mutators.  It's also a common pattern for services.

	my $resolver = Resolver->new(
		role => "resolver",
	);

	$resolver->timeout(60);

	$resolver->resolve(
		host => "poe.perl.org",
		type => "A",
	);

=head2 Task Completion by Exhaustion

Tasks may complete simply by finishing the work requested of them.

=head2 Task Cancelation Upon Request

Tasks may be canceled by authorized request.  For example, an object
or its owner may decide to cancel its work because too much time has
elapsed.

=head2 Task Cancelation Upon Program Exit

Programs may exit before tasks complete.  This form of exit is usually
pre-emptive, and objects may not have sufficient time or resources to
shut down neatly or completely.

=head2 Task Cancelation Upon Owner Cancelation

Objects tend to represent tasks.  Canceling an object implies
cancelation of all the objects that it uses to complete its work.  As
long as child objects are stored within their parents, this sort of
cascaded cancelation should be automatic.

=head1 Number of Tasks Per Object

An object may handle zero, one or many tasks.

=head2 Single-Shot Objects

Some objects live to perform just one task.  These objects passivate
when their tasks complete.  These are often helper objects.

	sub start_something {
		my $self = shift;
		$self->{something} = SomethingHappensOnce->new(
			role => "oneshot",
		);
	}

	sub on_oneshot_success {
		my $self = shift;
		my $something = delete $self->{something};
		print "done: ", $something->status(), "\n";
	}

=head2 Multi-Shot Objects

Some objects may perform more than one task.

=head3 One Task at a Time

Some objects are designed to repeat a task but only perform one
instance of a task at a time.  These may be services or repeatable
helpers.

	sub start_delay {
		my $self = shift;
		$self->{delayer} = Delay->new(
			role => "delay",
			time => 60, # seconds
		);
	}

	sub on_delay_complete {
		$self->{delayer}->repeat();
	}

=head3 Multiple Simultaneous Tasks

Some objects are designed to perform many instances of a task at once.
They may be helpers, but they are more often global objects that act
as services.  For instance:

	my $connection_pool = KeepAlivePool->new();

	sub start_connection {
		$connection_pool->connect(
			role    => "connector",
			scheme  => "http",
			host    => "poe.perl.org",
			port    => 80,
		);

		$connection_pool->connect(
			role    => "connector",
			scheme  => "http",
			host    => "delicious.com",
			port    => 80,
		);
	}

	sub on_connector_success {
		# use the connection
	}

	sub on_connector_failure {
		# handle an error
	}

=head1 Callback Types

I<Todo:> Define the calling conventions for each kind of callback.
Ideally they would be identical.

=head2 Coderef Callbacks

Coderef callbacks trigger a plain function call when one object
signals another.  Coderef callbacks are the kind that most Perl
libraries use.

	my $object = Class->new(
		on_callback => \&handler,
	);

	sub handler {
		print "I'm handling a callback!\n";
	}

=head2 Method Callbacks

Method callbacks allow classes and objects to handle responses from
other objects.  Prior art may be found in POE::Session's object_states
and package_states constructor parameters.  Class and object methods
are invoked identically in Perl, so the syntax to specify and invoke
them is the same.

Method callbacks require two parameters: the method name to invoke and
a reference to the object that implements that method.  The object
reference must be true and blessed, not stringified, which precludes
its use as a hash key.

The common case is for an object's owner to create and use a child
object to perform some subtask.  The child may respond later via
callback.  The object parameter to the callback isn't needed in this
case since the framework already knows each object's owner.

=head3 Methods Callbacks by Name

The most direct way to specify method callbacks is by method name.
The framework considers string callbacks to be the owners' method
names.

Objects may be transferred to new parents through an explicit method
call.  The framework's notion of the object's parent will change, and
the method callbacks will resolve to the new parent object.

I<Todo:> Objects can use multiple callback types.  It's a small change
to support multiple callback objects, but the design hasn't explored
this avenue yet.

Here an Owner object creates a Child.  The Child object notifies its
parent by invoking C<< $parent->handle_child_response() >>.

	package Owner;
	use Child;

	sub own_something {
		my $self = shift;
		$self->{child} = Child->new(
			on_callback => "handle_child_response",
		);
	}

	sub handle_child_response {
		my $self = shift;
		print "$self is handling a callback!\n";
	}

=head3 Methods by Role and Type

Calls and callbacks are a contract between objects.  Role-based
callbacks are a convenient way to implement these contracts.  If a
child object is assigned a role, its responses will either be those
explicitly set in the constructor or built by concatenating "on_", the
role name, "_", and the response type.

For example, if a child object is assigned the role of "resolver" and
it responds with either "success" or "failure", then it will attempt
to respond to the callbacks "on_resolver_success" and
"on_resolver_failure".

Explicit callbacks override role-based ones.

=head3 Multiple Callback Objects

I<Todo:> It may be useful to specify a callback that goes somewhere
other than the child object's parent, but the semantics feel brittle.
Role-based callbacks implement a contract between parent and child
object.  The contractual responsibilities are less clear when a
third-party object enters the mix.

I<Todo:> Consider a poetalk style framework for specifying
higher-level contracts between third-party objects.  This might
clarify contractual responsibilities of all objects in play.

I<Todo:> Consider a poecall style framework where parent objects may
act as glue for their children.

=head1 Calling Patterns

=head2 Standard Parameters

Aside from constructors (which are implemented with Moose),
application methods should receive two standard parameters:

=over 2

=item * $self - The framework object itself.

=item * $args - A hashref containing the actual named parameters.

=back

Magic may be avalable to alias $self and members of $args to lexical
variables within methods.

=head2 Return Values

Objects must be able to return typed responses for the on_role_type()
method to be formed.  The framework has two options for returning
typed responses.

=head3 Overloading Return

First, the framework can add the requirement that return() always
include type information.  Overloading return() limits an object to
zero or one response per method invocation, which seems restrictive.

	return(
		type => {
			key_1 => "value_1",
			...
		}
	);

=head3 Emitting Responses

A second way is to specify a new method that allows an object to emit
a response.  An object may emit() multiple responses per method
invocation, which may be convenient.

	$self->emit(
		type => {
			key_1 => "value_1",
			...
		}
	);

The two message return mechanisms are not incompatible.  It may be
possible (and even convenient) to support both.  However, emit() is
the safest option since it introduces entirely new syntax.
Overloading return() may be confusing since developers already have
strong expectations of its semantics.

In the following example, an Owner object creates a Child object with
the role of "doer".  The child does something and emits either a
"done" message on success or an "error" message on failure.  The
"error" message is explicitly handled via Child's "on_error"
constructor parameter.  Doneness is implicitly handled by Owner's
on_doer_done() method, via Child's role.

	package Owner;
	use Child;

	sub own_something {
		my $self = shift;
		$self->{child} = Child->new(
			role => "doer",
			on_error => "handle_doer_error",
		);
	}

	sub on_doer_done {
		my $self = shift;
		print "$self is handling doer's doneness!\n";
	}

	sub handle_doer_error {
		my $self = shift;
		print "$Self is handling doer's error!\n";
	}

=head2 Emit Semantics

I<Todo:> Emit's semantics are still largely a work in progress.

Children may emit responses to their parents via an emit() method they
call upon themselves.  The framework directs the emitted response to
the correct parent method to handle it.

emit() may have multiple semantics, none of which are considered
stable at this time.

=head3 Synchronous Emit

When appropriate, emit() should trigger a synchronous callback.
Appropriate times may be when the parent object is in the local
process and the synchronous callback will be brief.  I<Todo:> The
framework can recognize the former, but recognizing the latter is
harder and requires more consideraation.

=head3 Asynchronous Emit

emit() could in fact use POE to post() responses back to parents.  The
first implementation may do this unconditionally since the logic is
simpler, more consistent, and easier to explain.

=head3 Hybrid Emit

In some (ideally all) cases, emit() should attempt to recognize and
use the best available semantics.  For example, emit() may perform a
synchronous callback until it notices recursion.  At the point where
recursion would begin, it could fall back to asynchronous semantics to
break the loop.  If successful, this would provide the best balance
between safety and performance.

=head1 Messaging Patterns

=head2 Discrete Transactions

Discrete message transactions are generally single request/response
pairs between a I<client object> and a I<service object>.  Clients
initiate transactions by sending request messages to services.
Services handle requests, perform work, and eventually return response
messages to their clients.

Client and service are relative roles.  An object may be a service in
one situation and a client in another.  POE::Component::Client::HTTP
acts as a service to application code, but it's a client to other
components that help it fetch information from the web.

Client and service roles may correspond to parent and child objects,
but they are not required to.  Clients may be children, and responders
may be parents.  It depends on who shoots first.

Clients are sometimes called I<requesters> because they initiate
requests.  Likewise, services and helpers are also known collectively
as I<responders>.

Transactions begin with a client request and remain active until
canceled or a service's response is elicited.  Either party may cancel
a request deliberately or as a consequence of their destruction.
Transactions may end with zero, one or many responses to a single
request.

Responses may be nonterminal or terminal.  Nonterminal responses keep
the transaction open.  Terminal responses are followed by implicit
transaction cancelation.

Limited bidirectional communication is supported.  A client may
respond to nonterminal responses from the service.  The service is
allowed to send as many responses as it likes without restriction.
This pattern's asymmetry is restrictive and may indicate a flaw that
needs more work.

Message transactions are mainly used to communicate with multi-shot
services.  Single-shot objects are usually implicitly triggered during
creation, so it's more convenient to configure their tasks with the
constructor.

The mechanisms for message transactions aren't finalized.  POE::Stage
implements the asymmetrical pattern, but a symmetric one would be
better.  I<Todo:> Consider how POE::Stage's messaging could be made
symmetric.

=head3 One Requester, One Responder

A responder, either a service or a helper object, is created to handle
one or more requests from a single requester.

It's common for the responder to be an
L<implicitly managed|Implicit Management During Creation>
L<single-shot|Single-Shot Objects> object that
L<begins work on creation|Task Commencement During Instantiation>,
L<cancels work upon exhaustion|Task Completion by Exhaustion> and
L<automatically self-destructs|Automatic Self-Destruction>.

=head3 One Requester, Many Responders

One requester creates many responders, either serially or in a pool to
do work in parallel.

=head4 Serial Responders

In the serial pattern, the requester creates a responder for a single
task and replaces it each time the task completes.  One-shot objects
tend to be used for serial responders.

=head4 Parallel Responders

In the parallel pattern, the requester creates a pool of responders
and optionally replaces each responder as they finish.  The requester
usually owns the objects in the pool.

Parallel responders are often one-shot objects that are replaced
between requests.

Parallel responders may also be multi-shot.  In this case, each
responder may be configured differently to handle a separate class of
requests.  For example, a requester may use multiple HTTP clients,
each configured to connect through a different proxy.

=head3 One Responder, Many Requesters

A persistent or responder is created to do work for many requesters.
The responder is often a service, just as many POE::Component modules
are.

=head3 Many Requesters, Many Responders

This is a combination of the other message transaction patterns.  It's
documented for completeness and as a prompt for more consideration.

=head2 Persistent Inter-Object Channels

I<Todo:> Research and decide on semantics, then syntax.  Look at
Erlang, Haskell and Scala.  Check out various POE publish/subscribe
models, as well as message queues.

=head3 Transactions as Channels

Message transactions may be used as a form of ad hoc channels, but
limitations on when messages may be sent break the metaphor and
introduce potentially burdensome restrictions.  A true persisten
channel would allow entities on either end to send messages without
restriction.

Perhaps the largest problem with transactions as channels is what to
do when the client wants to send an entirely new request down an
existing channel.  Does the new request replace the old one?  Does it
create a sub-request?  If it creates a sub-request, should that
postpone the parent request?  If not, what happens when the parent
request completes first?  It's just ugly.  There should probably be a
better way.

=head2 Connections as Shared Memory

Poetalk is an experimental framework that builds upon Smalltalk
observable members and watchers.  It provides a framework where
objects can watch others' public members.  Watching objects are
automatically notified when these observed members change.  In a
sense, data is shared by message passing along unidirectional
connections.

The framework might mimic this behavior with watchers that can observe
members of other objects.

	$self->{watcher} = Watcher->new(
		object    => $another_object_reference,
		member    => "observable_member_name",
		on_change => "handle_observed_change",
	);

The requirement to use object references limits this pattern to
explicitly managed objects.  However, since watchers are holding
reference, it may be enough to hold references to the watchers.

Care must be taken to avoid circular references.  Heightened
indirection between objects and the code that manages them makes it
easier to lose track of objects.  Ideally the framework should detect
circular references and intelligently weaken key references to avoid
them without releasing objects entirely.

I<Todo:> Develop the semantics and syntax for this mechanism.

I<Todo:> What about objects in remote processes?

While working on poecall, it became apparent that more that both edge
and level notifications may be useful.

=head2 Notification on Change

An "on_change" callback would be triggered whenever the watched data
member actually changes.  Merely setting it to the same value would
not be sufficient to trigger a callback.  This is "edge triggered"
semantics in digital circuits.

=head2 Notification on Set

An "on_set" callback would be triggered for every set, regardless
whether the data changed.  This is similar to but not exactly the same
as "level triggered" semantics in digital circuits.

=head2 Multiple Observers

A single data member may be observed by many watchers.  If we know
this in advance---for example when a parent object is wiring up its
children---then there should be a convenient way to specify them all
at once.

=head1 Continuations

Continuations are encapsulated bits of program state that can be
passed around and swapped in and out as needed.  Each includes an
instruction pointer and all the program state required to resume a
program from that point in its execution.

Perl supports coroutines by grafting its interpreter onto an event
dispatcher.  This is done deep in its implementation using seriously
sharp implements.

This framework explores continuations as explicit objects to manage
execution state between method calls in a larger task.  For example,
the framework creates a continuation when a request is made.  This
continuation is associated with the request.  Responses to that
request will include the same continuation, so that response handlers
may remember what was happening at the time the request was initiated.

The following example illustrates a continuation scenario, but it
doesn't necessarily use the mechanism that will be in the framework.
In this scenario, a request is created and given a name.  The
request's continuation is available when the response comes back.

	sub send_request {
		my $self = shift();
		my $request = Request->new();
		$request->{name} = "gorf";
	}

	sub handle_response {
		my ($self, $response) = @_;
		print "This response is to request $response->{name}\n";
	}

Continuations are most often associated with asynchronous requests and
responses.

Multiple continuations may be active at once.  A continuation may be
created for a subrequest while the parent request's continuation is
active.

Lexical variables may be aliased into continuations as a shortcut.
The Lexical::Persistence module was developed as a spin-off of
research in this area.  Because continuations may reuse data member
names, it's important for their members to be aliased into the lexical
context with different prefix names.  A request and sub-request
continuation may both contain a $timeout member.  The current code may
wish to access both without variable collision.  We might
automatically map $req_timeout to C<< $request->{timeout} >>, and
$sub_timeout to C<< $sub_request->{timeout} >>.

The framework can walk message handler pads to find lexical variables
with known prefixes and automatically map them to their associated
contexts.

=head2 Task Continuation

When a service receives a request to perform a task, it's also given a
continuation within which to store temporary state related to that
task.  This I<task continuation> lives in the service until the
request is terminated or completed.  The recommended lexical prefix
for I<task variables> is "task_".

Task variables are not shared between objects, even ones that work
together to perform the same task.  Task variables are not shared
between tasks, even ones that are performed by the same object.

	TODO - Example.

Only one task continuation may be active during a method call.  Many
tasks may be performed simultaneously, but a method will only see one
of them at a time.

=head2 Subtask Continuations

Clients may associate continuations with the objects and requests they
create to perform subtasks.  These I<request continuations> live in
their requesting clients until the request is terminated or completed.
Request continuations are available wherever the request or one of its
responses is.  "req_" is the recommended lexical variable prefix for
I<request variables>.

Request variables are usually set at the time a request is created,
either using the expose() function or a request's constructor
parameter.

	TODO - Example.

Multiple request continuations may be active while requests are being
created.  However since only one response may be handled at a time,
there may be only one request continuation available in a response
handler.

=head2 Other Magic Variables

Lexical::Persistence supports generic lexical aliasing to other
contexts.

=head3 Self Variables

The lexical $self variable may be mapped to the first method
parameter, which is often the object itself.  I<Self variables> may
begin with "self_" and be aliased to data members within $self.  $self
itself may be automatically populated from $_[0] to avoid the explict
assignment.

	sub method {
		my $self_member;      # magic
		my $self->another();  # more magic
	}

=head3 Parameter Variables

I<Parameter variables> may begin with "par_" and be mapped to members
of $_[1].  This parameter is specified by the framework to always be
the method's parameters, passed in as a hash reference.  These two
methods may be equivalent.

	sub mundane_way {
		my ($self, $args) = @_;
		print "$self called with $args->{name}\n";
	}

	sub magic_way {
		my ($self, $arg_name); # magic
		print "$self called with $arg_name\n";
	}

=head2 Caveats With Contiuations

This section contains notes about edge cases found in POE::Stage.

=head3 Continuation Clash

This flavor of continuation was previously explored and developed in
POE::Stage.  There were some unresolved issues at the time,
particularly when handling a response from a sub-object.  For example,
this situation creates a context where three continuations are active:
an inbound request continuation, an inbound response continuation, and
a continuation for the outbout request that triggered the inbout
response.

=over 2

=item * Client object makes a request to current object.

=item * Current object makes a request to a sub-object.

=item * Sub-object returns a response to the current object.

=back

It's vital for a clean metaphor to clearly differentiate between the
inbound and outbound requests.  POE::Stage does not do this well.

The problem may be genericised into the question, "How do we handle
more than one continuation of the same type?"  It's a problem because
of type-based prefixes.  Which request does $req_foo map into?

An obvious solution is to assign each continuation a different named
role and use the role names as prefixes.  In theory this scales to a
modest amount of role overlap.  I<Todo:> Determine the most complex
practical case of continuation overlap to see whether the framework
can subsume this overhead.

POE::Stage also provides req() and rsp() as functional accessors to
the current request and response.  To scale this concept up, the roles
for each continuation must be known in advance.  The roles and their
quantities must be known in advance for this to succeed.

POE::Stage used the relative terms I<request continuation> and
I<response continuation>, but these are confusing because their roles
change depending on the narrator's point of view.  It's important to
move to more objective terms.

=head3 Request Cleanup

It's also imperative that an inbound response may be used to find the
outbound requests that triggered them.  This is commonly used to
remove defunct requests after their responses have arrived.

One way to do this might be to place the location in the response
continuation.

	sub requester_send_request {
		my $self = shift();
		$self->{request_member} = POE::Request->new(...);
		expose $request => my $member_name;
		$member_name = "request_member";
	}

Now the responder can examine rsp()->{member_name} to find out which
$self member to destroy.

	sub handle_response {
		my $self = shift();
		delete $self->{ rsp()->{member_name} };
	}

This will be common enough that the framework should provide a
standard mechanism.

=head1 Metaphors

=head2 Extending the Actor Metaphor

I<Todo:> The descriptions here are a bit off.  Clarify and specify
them better.  For example, Stage and Director seem to have overlapping
concerns.

=head3 Actor

Actors are objects that can receive command messages.  They are
described as L<services|Services> earlier in this document.
POE::Session is a kind of actor.

Actors are not quite like computer-science actors.  They do not
necessarily include mailboxes, nor do they necessarily actively await
messages.

=head3 Prop

Props are L<helper|Helpers> objects.  They are intended to be
instantiated and held by some actor, not to live on their own.  They
may receive events, but they do so in service to some actor.
POE::Watchers from POE::Stage are similar to props, as are POE::Wheel
classes.

=head3 Director

Director represents message routing and dispatching.  It may represent
the equivalent of POE::Kernel, or it may be an abstracted interface to
POE::Kernel.

=head3 Stage

Stages represent isolated computational units, such as processes or
iThreads.  Stages act as a shared mailbox and dispatch loop for
multiple related actors.  POE::Group from POE's 5.005-threaded design
is similar.

=head4 Cooperative Stages

Cooperative stages act as thin interfaces between POE::Kernel and
actors.  These stages don't really have queues.  They immediately
forward POE::Kernel events to the appropriate actors.

=head4 Threaded Stages

Threaded stages act as bidirectional queues between POE::Kernel (which
lives in the main thread) and the stage that lives in some subthread.
It's quite likely that many things cannot run in threaded stage since
it would require straddling the thread boundary.

For example, it would be difficult (if not impossible) for Tk to
dispatch POE::Kernel events in one thread while creating widgets in
another.

=head4 Forked Stages

It should also be convenient to create actors in child processes.
These actors will also be unable to share resources with POE::Kernel.

=head4 Remote Stages

A program should be able to find an actor on a stage in another
process or on another machine across a network.  Remote stages are
implicit in the use of remote actors.

=head3 Propmaster

Propmaster is a hypothetial ORM or object loader.  This metaphor is a
bit off since a propmaster would also manage actors.

=head1 Ideas to Consider

=head2 XPath to Find Objects

POE's aliases are too restrictive.  The framework will implement its
own.  This topic considers using object roles as aliases.

Object roles are important to this framework.  They simplify callback
interfaces and object management.  They may also be used as a
hierarchical namespace for registering and finding objects.

Consider a program that crawls a static list of URLs to verify whether
they exist.  It may have a structure similar to the following roles
and structure.

	<main>
		<application>
			<http_client>
				<dns_client>
					<worker/>
					<worker/>
					<worker/>
				</dns_client>
				<keepalive_connector>
					<socket/>
					<socket/>
				</keepalive_connector>
				<request/>
				<request/>
				<request/>
			</http_client>
		</application>
	</main>

Unlike POE aliases, the framework supports multiple objects per role.

Since the program is structured like an object tree, we can represent
it in XML.

We can find objects using XPath, either by manipulating a DOM in
memory or using a module like Tree::XPathEngine to access a native
Perl tree structure.

Objects may be found by absolute path, relative path, or role
regardless of path.

	my @workers = Object->find('//worker');
	my @http_requests = Object->find('//http_client/request');
	my @http_clients = Object->find( '/main/application/http client');

It quickly becomes apparent that roles as object attributes is
tedious.  It might be better to assume everything is an object and
name the tags after the roles:

XPath may not be the right choice, but it seems very flexible.  What
kinds of edge cases make it undesirable?

Storing the program structure in a DOM also allows it to be serialized
and shared trivially.  How hard would it be to include public
interfaces in the DOM?

=head3 Problems with XPath Object Addressing

As Robert Grimes pointed out, there seems to be very little actual
need for finding objects like this.  Most objects interact with each
other in local ways:

=over 2

=item * Parent interacts with children.

=item * Children interact with parents.

=back

Children may interact with siblings, but this usually happens through
a mediator such as the parent.

XPath addressing may also permit objects to sidestep encapsulation.
Objects may need to tag their children as "private" in order to keep
them out of the DOM or to only make them visible by the parent.

While nifty, the drawbacks may negate the benefits.  There need to be
compelling reasons to follow down this path.  Are there useful use
cases?

=head2 Connections as Helpers

Helper objects could act as proxies for remote helpers and services.
They would expose remote object interfaces locally.  All calls would
be asynchronous commands with asynchronous callbacks.

Synchronous calls may be possible using event loop features like
run_one_timeslice() or coroutines.  Many mechanisms to support
synchronous calls limit compatibility or portability, which limits
their usefulness for a portabile class framework.  For example, some
event loops don't support run_one_timeslice().

Threads aren't considered since processes work better in Perl.
Forking uses fewer resources on UNIX systems, and it is an interface
to threading on Windows.  Multiprocessing is also more robust in
either case; a process may die off and be restarted, but a thread
failure would most likely kill off the entire program.

=head3 Remote Object Type

=head4 Remote Helper

A local helper may represent a remote helper.  The remote helper is
created during the local helper's setup.

=head4 Remote Service

A local helper may represent a remote service.  The local helper
attackes to a remote service already running.

=head3 Remote Object Existence

=head4 Remote Object Already Exists

The remote object may already exist.  This is true in the case of
services.

=head4 Remote Object Created on Demand

Remote helpers are always created on demand.  Remote services may be
created on demand if needed or upon request.

=head3 Remote Process Existence

=head4 Remote Process Already Exists

The remote process may already exist.  Creating the local helper
triggers a connection to the remote process.

=head4 Remote Process Created on Demand

The helper constructor may specify that a new process be created to
drive the remote object.  This may be done by forking or spawning a
new program on the local machine, or by contacting a remote machine to
start a process.

The remote machine may include an incompatible version of Perl, which
could complicate running programs on demand.

=head3 Remote Class Existence

=head4 Remote Process Has Required Class

The remote process may already have the required helper or service
class installed.  Complications arise when that class is of a version
that isn't compatible with the local program.

=head4 Remote Process Needs Required Class

The remote process may not have the required class installed.  It
may be possible to push the class into the remote process, but this
has serious drawbacks.

The class pushed to the remote process may not function with the
version of Perl running there.

The required class may be pushed across only for the program to
discover that dependencies are also missing.  This may be worked
around if the remote process has access to install modules from CPAN.
Another option is to bundle up the entire application and its
dependencies as a tarball and transmit that across.

Compiled modules have their own problems, especially if architectures
differ between machines.

=head3 Further Considerations

=head4 Blocking Constructors

Proxy objects imply a measure of blocking, which follows as a
consequence of the expectation that an object's constructor
immediately returns a usable object.  This is usually not a concern.
Objects generally construct rapidly, so their blocking is minimal.

Remote procedure calls involve network operations, which may block
significantly.  This introduces problems in a cooperative multitasking
framework.

The framework could return helper objects right away but also require
asynchronous notification of their readiness.  POE::Wheel classes do
this, although it's somewhat awkward to people who expect normal
constructor semantics.

Promises are another option.  Constructors may return objects which
block until completion when they are dereferenced rather than within
new().  Programs which wait long enough between construction and use
may not notice blocking.  The semantics are somewhat misleading since
the interface implies immediate use.

=head4 Conserving TCP Sockets

One TCP connection per remote object is heavy.  Each remote object
construction or connection incurs TCP setup delays.  Destroying
objects incurs TCP wait state congestion in the operating system.

It makes sense to multiplex object relationships across a limited
number of sockets, perhaps as few as one per remote process.  This may
be reduced to a single connection if an external message router is
available.

BXXP seems to be a generic protocol for meultiplexing virtual
connections over a socket.  It may be worth considering.

=head1 Technology Questions

=head2 How are new Moose types defined?

=head2 How may hooks be affixed to Moose members?

Attribute traits allow accessors and mutators to take on new
behaviors.  Change notification hooks may be added to public members
that a class wishes to define observable.

=head2 How does Moose map to this framework's features?

Moose features seem to be coupled to classes rather than individual
objects.  The framework needs more dynamic meta-object support.  How
much of Moose can be used to support this framework's desired feature
set?

=cut
