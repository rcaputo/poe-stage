=head1 Introduction

This document intends to be an exhaustive catalog of runtime object
use and interaction patterns.  It aims to be generally applicable, but
it also recommends "best of breed" patterns for a particular object
framework design called I<the framework>.

Any usable object framework must support every useful design pattern,
either through core mechanisms or by extension.  While the framework
strives to make common things easy, it must not preclude useful
patterns.  One reason for cataloging as many patterns as possible is
to ensure that all possible patterns are considered.

=head1 Object Categories

=head2 Helpers

Helper objects are created and owned by another object to perform one
or more tasks.  Most objects are helpers.

	sub do_something {
		my ($self, $args) = @_;
		$self->{helper} = POE::Helper->new();
	}

Helpers often have synchronous-looking interfaces, but they may behave
asynchronously if appropriate.  Synchronous methods may trigger
asynchronous processes on behalf of the caller.

I<Todo:> Is this confusing?  How can the framework clarify when a
method is synchronous or asynchronous?  Do we need a naming convention
to differentiate between synchronous and asynchronous methods?

=head2 Services

Services are stand-alone objects that handle asynchronous events.
They may be stored in a widely-scoped registry or namespace.  They may
be singletons that respond to class methods.  They may be visible to
remote processes or objects.

I<Todo:> Services have not been considered in great depth.  The
framework must be capable of cleanly supporting services, otherwise
its design will need to be changed.  One purpose of documenting the
framework in detail is to examine the interactions between concepts
and explore its extensibly before too much code is written.

=head1 Object Management

Perl takes care of low-level memory management, but the language still
requires programs to manage objects.  Perl programs manage objects by
holding references to them.  Perl considers unreferenced objects to be
unused, and it destroy them and reclaim their memory.  It's common for
an object reference to be stored somewhere until the object stops
being useful.

	my $object = Object->new();
	$object->do_stuff();
	$object = undef;

=head2 Object Scope

=head3 Within One Object

An object is created by another object, and it is stored within its
creator for use by its creator.  The object is generally used directly
only by its parent.  The framework focuses on this use pattern, but it
should support the others.

	package Object;

	sub do_something {
		my $self = shift;
		$self->{another_object} = AnotherObject->new();
	}

=head3 Within Multiple Objects

An object is created and passed among (or exposed to) two or more
objects.  Use of the object is generally not coordinated, so the
object must handle being called at odd times.  Perl usually prevents
the object from being re-entered however.

	package ObjectFactory;

	sub create {
		return Object->new(@stuff);
	}

I<Todo:> The framework doesn't support this model well.  How can it be
improved?

=head3 Within a Namespace

An object is created and stored in a namespace which publishes it to
one or more other objects.  Users tend to look up these objects as
needed rather than hold onto them.

	package Something;

	my %namespace;

	sub do_something {
		my ($self, $name) = @_;
		$namespace{$name} = AnotherObject->new();
	}

I<Todo:> Formalize namespaces and perhaps distributed objects along
the way.

=head2 Object Relationships

Perl's concept of ownership is tightly coupled to object references.
Whatever holds a reference to an object owns that object.  An object
may have multiple owners in Perl, depending on what and how many
things refer to the object.  Object references may be copied and
passed around without restriction.

I<Todo:> Can we co-opt Perl's ownership, or must we really have our
own separate concept?  We would need a way to know which objects and
classes held references to other objects.

The framework manages its own concept of ownership based on the idea
that child objects are created to perform work.  Objects' creators are
their default owners.  The framework's usefulness would be limited if
an object couldn't be given to a new owner.

Interaction is common between an object and its owner.  The framework
recognizes this and implicitly tracks these parent-child relationships
among all framework-based objects.  At any moment, the framework
should know

=over 2

=item * the currently active object,

=item * every object's creator (or parent or owner),

=item * and every object's child objects.

=back

Child objects must know which objects created them, so they know which
objects to help.  Services may need to know which objects made
requests so they may send responses to the right ones.  Parent objects
may pass $self to their children, but doing so and the mechanisms of
storing the parent are a lot of redundant work.  It would be more
convenient for everything to implicitly know which object is currently
active, so the framework tries to accomplish this in its base classes.

There are at least two ways to track the current object.  Examine the
call stack via caller() in package DB, or have the framework call
everything.  The former is more convenient from the user's point of
view, but it's harder to implement reliably.  The latter imposes more
restrictions on application design, but POE and POE::Stage have shown
that it's more reliable.

I<Todo:> Nick Perez suggests a couple possibilities.  He writes
(paraphrased): It seems like there should be an easier way to
determine your immediate parent without having to walk the caller
stack.  Maybe using a decorator that injects the current $self.  A
scope hack.  You could also try using something rjbs has been working
on: MRO::Magic.  If you want to know more about custom delarators,
take a look at Devel::Declare and MooseX::Declare.  A simple C<<
parent SomeObject->new() >> could deliver what you want.  It is a
little magicky, but it might inject $self a lot easier than walking
the caller stack.

All objects are I<not> created equal.  Basic, entirely local and
synchronous objects need not be tracked at all.

=head2 Explicitly Manged Objects

Most object management is explicit.  An object is created, and its
creator stores a reference to it somewhere.  The object's creator uses
the reference to invoke, access or alter the object.  When the object
is no longer needed, its creator releases its reference, and it
destructs.

	sub some_method {
		my $self = shift();
		$self->{sub_object} = Object->new();
		$self->{sub_object}->do_something();
	}

	sub sometime_later {
		my $self = shift();
		delete $self->{sub_object};
	}

=head2 Implicitly Managed Objects

Implicit object management is a concept introduced by the framework,
so it will be described in terms of what the framework will do.

Objects may be implicitly managed by the framework on behalf of their
owners.  This simplifies management and cleanup of objects that aren't
accessed between the time of creation and destruction.  As a corolary,
the framework also provides some introspective methods to access
implicitly managed objects in cases where minimal access is required.

The framework internally tracks objects and their creators in a tree
where creators are parent nodes for the objects they create.  Objects
may be described as I<parents> or I<children> when talking about them
in these roles.  Parents may sometimes be called I<owners> when it
makes sense to consider ownership semantics.

Implicitly managed objects are usually self-destructing as well.
I<Todo:> Link to section on self destruction.

Since this is Perl, the framework provides more than one way to
implicitly manage objects.

=head3 Implicit Management on Request

Objects are implicitly managed by detaching them from their parents.
A parent object may detach a child from itself, allowing the object to
be implicitly managed by the framework.

	sub create_configure_and_detach_an_object {
		my $object = Object->new();
		$object->timeout(60);
		$object->detach();
	}

I<Todo:> Is detach() a good name for this?

I<Todo:> Should the child be asked to detach itself, or should the
parent be told to detach its child?  It can't be both, as detach() is
implemented in the same base class used by the parent and its
children.  A beter name might clear up the semantics.

=head3 Implicit Management During Creation

Often an object will be sufficiently configured during construction.
The framework supplies a separate constructor, spawn(), that
implicitly detaches the child from its creator.  This object will be
implicitly managed by its creator.

	sub spawn_an_object {
		my $self = shift(); # unused
		Object->spawn();
	}

spawn() itself might be written in terms of new() and detach().  Note
that spawn() doesn't return a reference to the new object.  An
application should decide which semantics are needed and choose the
right constructor for the job.

	sub Object::spawn {
		my ($class, @args) = @_;
		my $new_object = $class->new(@args);
		$new_object->detach();
		undef;
	}

=head3 Inspecting Implicitly Managed Objects

Implicitly managed objects are generally hidden, but the framework
allows them to be examined and manipulated with some effort.

It is probably a sign that explicit management is the better design if
an application finds itself overly burdened by inspecting implicitly
managed objects.

The framework's base object class provides methods that return an
object's implicitly owned children.

	sub owner_method {
		my $self = shift();
		my @children = $self->child_objects();
		# ... do something ...
	}

A parent object may limit inspection by object class and/or role.

	sub shutdown_my_resolvers {
		my $self = shift();
		foreach my $resolver ($self->child_objects(role => "resolver")) {
			$resolver->shutdown();
		}
	}

	sub cancel_my_delays {
		my $self = shift();
		foreach my $delay ($self->child_objects(class => "Delay")) {
			$delay->cancel();
		}
	}

Retrieved objects may merely be counted.  For example, to refill a
worker pool.

	sub refill_resolver_pool {
		my $self = shift();
		while ($self->child_objects(role => "resolver") < 10) {
			Resolver->new(
				role => "resolver",
				host => shift(@hosts_to_resolve),
				type => "A",
			);
		}
	}

=head2 Transferring Object Ownership

Ownership conveys certain benefits.  For example, the framework
provides convenience methods for object communication between a child
and its parent.  Implicit object management is also tightly coupled to
the concept of object ownership.

I<Todo:> The single owner model implies certain restrictions to
parental benefits.  Are these restrictions limiting?  Can they be
lifted through a different ownership mechanism?

The exact mechanism for object movement isn't firm yet, but it may be
as simple as calling a method from the new owner.  The object's new
parent would call the method on the object being claimed.  This
take_object() method might be implemented on the parent.

	sub take_object {
		my ($self, $object) = @_;
		$object->move();
	}

Transferrence failure should be reported with an exception, which
would guarantee that the program fails close to the actual problem.

Different owners may implement different interfaces for handling a
child's responses.  It should be possible to attach a moving object to
its new parent's interface regardless of the differences.  The
proposed move() method may take "role" and response parameters to
adjust how the child interacts with its new owner.  Here the moved
object is assigned a new role and a specific failure method.

	sub take_object {
		my ($self, $object) = @_;
		$object->move(
			role       => "resolver",
			on_failure => "special_failure_method",
		);
	}

A factory may now create new objects on behalf of other objects, then
ask new owners to take them.

	sub object_factory {
		my ($self, $recipient) = @_;
		$recipient->take_object( Object->new() );
	}

Role and callback validation should happen at new(), spawn() and
move() time.  These methods can ensure that an object's owner can
handle all required responses.

I<Todo:> This level of validation requires some introspection into the
parent class and the child's command/response interface.  Moose or
Class::MOP can provide the parent class introspection, but something
new must be added to query the child's request/response interface.

I<Todo:> Explore the implications of role and callback validation
timing.  For example, it means that required response handlers must be
known before child objects are created, spawned or moved.  What
restrictions does this impose on object use patterns?  I have a strong
feeling that I'm overlooking an important side effect.

=head2 Object Destruction

=head3 Automatic Self-Destruction

Objects may automatically self-destruct when they are done with their
work.  Self-destruction can be thwarted by posession of additional
object references, so self-management or careful attention to object
lifespans is required.

Here a name resolver is spawned to resolve a single host name.  It
will self-destruct once its response---either success or failure---is
delivered.

	Resolver->spawn(
		role => "resolver",
		host => "poe.perl.org",
		type => "A",
	);

	sub on_resolver_success {
		# handle successful response
	}

	sub on_resolver_failure {
		# handle error response
	}

Applications may also use weak references to manipulate self-managed
objects.  Applications must remember to occasionally clean up defunct
weak refereces, or they may encounter memory leaks.  A better
alternative may be to inspect self-managed objects when needed.
I<Todo:> Link.

=head3 Object Destructs Upon Request

Destruction upon request is useful for canceling tasks before they
complete.  Explicitly managed objects may be destroyed by releasing
their object references.

	sub cancel_sub_object {
		my $self = shift();
		delete $self->{sub_object};
	}

Explicit shutdown() methods are recommended, especially if shutdown is
a complex process that can't be completed within a single destructor
call.

	sub shutdown_sub_object {
		my $self = shift();
		$self->{sub_object}->shutdown();
	}

	sub on_subobject_destruction {
		my $self = shift;
		delete $self->{sub_object};
	}

Implicit management may make explicit shutdown easier since child
objects are automatically cleaned up.

=head3 Object Never Destructs

Objects that are used for the lifespan of an application are never
destroyed.  This pattern is common, and it often causes edge cases in
object managers.

=head1 Task Lifespan

=head2 Task Commencement During Instantiation

Objects creation and task commencement can be tightly coupled.  Object
constructors can bootstrap the work to be performed.  This is a common
pattern for helper objects.

	my $resolver = Resolver->new(
		role => "resolver",
		host => "poe.perl.org",
		type => "A",
	);

	sub on_resolver_success {
		# continue with successful path
	}

	sub on_resolver_failure {
		# handle error
	}

=head2 Task Commencement Upon Request

Task commencement may be delayed until an explicit request is made.
This decouples the work from the object's constructor.  This pattern
is useful for lazy objects and to allow task customization by
mutators.  It's also a common pattern for services.

	my $resolver = Resolver->new(
		role => "resolver",
	);

	$resolver->timeout(60);

	$resolver->resolve(
		host => "poe.perl.org",
		type => "A",
	);

=head2 Task Completion by Exhaustion

Tasks may complete simply by finishing the work requested of them.

=head2 Task Cancelation Upon Request

Tasks may be canceled by authorized request.  For example, an object
or its owner may decide to cancel its work because too much time has
elapsed.

=head2 Task Cancelation Upon Program Exit

Programs may exit before tasks complete.  This form of exit is usually
pre-emptive, and objects may not have sufficient time or resources to
shut down neatly or completely.

=head2 Task Cancelation Upon Owner Cancelation

Objects tend to represent tasks.  Canceling an object implies
cancelation of all the objects that it uses to complete its work.  As
long as child objects are stored within their parents, this sort of
cascaded cancelation should be automatic.

=head1 Number of Tasks Per Object

An object may handle zero, one or many tasks.

=head2 Single-Shot Objects

Some objects live to perform just one task.  These objects passivate
when their tasks complete.  These are often helper objects.

	sub start_something {
		my $self = shift;
		$self->{something} = SomethingHappensOnce->new(
			role => "oneshot",
		);
	}

	sub on_oneshot_success {
		my $self = shift;
		my $something = delete $self->{something};
		print "done: ", $something->status(), "\n";
	}

=head2 Multi-Shot Objects

Some objects may perform more than one task.

=head3 One Task at a Time

Some objects are designed to repeat a task but only perform one
instance of a task at a time.  These may be services or repeatable
helpers.

	sub start_delay {
		my $self = shift;
		$self->{delayer} = Delay->new(
			role => "delay",
			time => 60, # seconds
		);
	}

	sub on_delay_complete {
		$self->{delayer}->repeat();
	}

=head3 Multiple Simultaneous Tasks

Some objects are designed to perform many instances of a task at once.
They may be helpers, but they are more often global objects that act
as services.  For instance:

	my $connection_pool = KeepAlivePool->new();

	sub start_connection {
		$connection_pool->connect(
			role    => "connector",
			scheme  => "http",
			host    => "poe.perl.org",
			port    => 80,
		);

		$connection_pool->connect(
			role    => "connector",
			scheme  => "http",
			host    => "delicious.com",
			port    => 80,
		);
	}

	sub on_connector_success {
		# use the connection
	}

	sub on_connector_failure {
		# handle an error
	}

=head1 Callback Types

I<Todo:> Define the calling conventions for each kind of callback.
Ideally they would be identical.

=head2 Coderef Callbacks

Coderef callbacks trigger a plain function call when one object
signals another.  Coderef callbacks are the kind that most Perl
libraries use.

	my $object = Class->new(
		on_callback => \&handler,
	);

	sub handler {
		print "I'm handling a callback!\n";
	}

=head2 Method Callbacks

Method callbacks allow classes and objects to handle responses from
other objects.  Prior art may be found in POE::Session's object_states
and package_states constructor parameters.  Class and object methods
are invoked identically in Perl, so the syntax to specify and invoke
them is the same.

Method callbacks require two parameters: the method name to invoke and
a reference to the object that implements that method.  The object
reference must be true and blessed, not stringified, which precludes
its use as a hash key.

The common case is for an object's owner to create and use a child
object to perform some subtask.  The child may respond later via
callback.  The object parameter to the callback isn't needed in this
case since the framework already knows each object's owner.

=head3 Methods Callbacks by Name

The most direct way to specify method callbacks is by method name.
The framework considers string callbacks to be the owners' method
names.

Objects may be transferred to new parents through an explicit method
call.  The framework's notion of the object's parent will change, and
the method callbacks will resolve to the new parent object.

I<Todo:> Objects can use multiple callback types.  It's a small change
to support multiple callback objects, but the design hasn't explored
this avenue yet.

Here an Owner object creates a Child.  The Child object notifies its
parent by invoking C<< $parent->handle_child_response() >>.

	package Owner;
	use Child;

	sub own_something {
		my $self = shift;
		$self->{child} = Child->new(
			on_callback => "handle_child_response",
		);
	}

	sub handle_child_response {
		my $self = shift;
		print "$self is handling a callback!\n";
	}

=head3 Methods by Role and Type

Calls and callbacks are a contract between objects.  Role-based
callbacks are a convenient way to implement these contracts.  If a
child object is assigned a role, its responses will either be those
explicitly set in the constructor or built by concatenating "on_", the
role name, "_", and the response type.

For example, if a child object is assigned the role of "resolver" and
it responds with either "success" or "failure", then it will attempt
to respond to the callbacks "on_resolver_success" and
"on_resolver_failure".

Explicit callbacks override role-based ones.

=head3 Multiple Callback Objects

I<Todo:> It may be useful to specify a callback that goes somewhere
other than the child object's parent, but the semantics feel brittle.
Role-based callbacks implement a contract between parent and child
object.  The contractual responsibilities are less clear when a
third-party object enters the mix.

I<Todo:> Consider a poetalk style framework for specifying
higher-level contracts between third-party objects.  This might
clarify contractual responsibilities of all objects in play.

I<Todo:> Consider a poecall style framework where parent objects may
act as glue for their children.

=head1 Calling Patterns

=head2 Standard Parameters

Aside from constructors (which are implemented with Moose),
application methods should receive two standard parameters:

=over 2

=item * $self - The framework object itself.

=item * $args - A hashref containing the actual named parameters.

=back

Magic may be avalable to alias $self and members of $args to lexical
variables within methods.

=head2 Return Values

Objects must be able to return typed responses for the on_role_type()
method to be formed.  The framework has two options for returning
typed responses.

=head3 Overloading Return

First, the framework can add the requirement that return() always
include type information.  Overloading return() limits an object to
zero or one response per method invocation, which seems restrictive.

	return(
		type => {
			key_1 => "value_1",
			...
		}
	);

=head3 Emitting Responses

A second way is to specify a new method that allows an object to emit
a response.  An object may emit() multiple responses per method
invocation, which may be convenient.

	$self->emit(
		type => {
			key_1 => "value_1",
			...
		}
	);

The two message return mechanisms are not incompatible.  It may be
possible (and even convenient) to support both.  However, emit() is
the safest option since it introduces entirely new syntax.
Overloading return() may be confusing since developers already have
strong expectations of its semantics.

In the following example, an Owner object creates a Child object with
the role of "doer".  The child does something and emits either a
"done" message on success or an "error" message on failure.  The
"error" message is explicitly handled via Child's "on_error"
constructor parameter.  Doneness is implicitly handled by Owner's
on_doer_done() method, via Child's role.

	package Owner;
	use Child;

	sub own_something {
		my $self = shift;
		$self->{child} = Child->new(
			role => "doer",
			on_error => "handle_doer_error",
		);
	}

	sub on_doer_done {
		my $self = shift;
		print "$self is handling doer's doneness!\n";
	}

	sub handle_doer_error {
		my $self = shift;
		print "$Self is handling doer's error!\n";
	}

=head2 Emit Semantics

I<Todo:> Emit's semantics are still largely a work in progress.

Children may emit responses to their parents via an emit() method they
call upon themselves.  The framework directs the emitted response to
the correct parent method to handle it.

emit() may have multiple semantics, none of which are considered
stable at this time.

=head3 Synchronous Emit

When appropriate, emit() should trigger a synchronous callback.
Appropriate times may be when the parent object is in the local
process and the synchronous callback will be brief.  I<Todo:> The
framework can recognize the former, but recognizing the latter is
harder and requires more consideraation.

=head3 Asynchronous Emit

emit() could in fact use POE to post() responses back to parents.  The
first implementation may do this unconditionally since the logic is
simpler, more consistent, and easier to explain.

=head3 Hybrid Emit

In some (ideally all) cases, emit() should attempt to recognize and
use the best available semantics.  For example, emit() may perform a
synchronous callback until it notices recursion.  At the point where
recursion would begin, it could fall back to asynchronous semantics to
break the loop.  If successful, this would provide the best balance
between safety and performance.

=head1 Messaging Patterns

=head2 Discrete Transactions

Discrete message transactions are generally single request/response
pairs between a I<client object> and a I<service object>.  Clients
initiate transactions by sending request messages to services.
Services handle requests, perform work, and eventually return response
messages to their clients.

Client and service are relative roles.  An object may be a service in
one situation and a client in another.  POE::Component::Client::HTTP
acts as a service to application code, but it's a client to other
components that help it fetch information from the web.

Client and service roles may correspond to parent and child objects,
but they are not required to.  Clients may be children, and responders
may be parents.  It depends on who shoots first.

Clients are sometimes called I<requesters> because they initiate
requests.  Likewise, services and helpers are also known collectively
as I<responders>.

Transactions begin with a client request and remain active until
canceled or a service's response is elicited.  Either party may cancel
a request deliberately or as a consequence of their destruction.
Transactions may end with zero, one or many responses to a single
request.

Responses may be nonterminal or terminal.  Nonterminal responses keep
the transaction open.  Terminal responses are followed by implicit
transaction cancelation.

Limited bidirectional communication is supported.  A client may
respond to nonterminal responses from the service.  The service is
allowed to send as many responses as it likes without restriction.
This pattern's asymmetry is restrictive and may indicate a flaw that
needs more work.

Message transactions are mainly used to communicate with multi-shot
services.  Single-shot objects are usually implicitly triggered during
creation, so it's more convenient to configure their tasks with the
constructor.

The mechanisms for message transactions aren't finalized.  POE::Stage
implements the asymmetrical pattern, but a symmetric one would be
better.  I<Todo:> Consider how POE::Stage's messaging could be made
symmetric.

=head3 One Requester, One Responder

A responder, either a service or a helper object, is created to handle
one or more requests from a single requester.

It's common for the responder to be an
L<implicitly managed|Implicit Management During Creation>
L<single-shot|Single-Shot Objects> object that
L<begins work on creation|Task Commencement During Instantiation>,
L<cancels work upon exhaustion|Task Completion by Exhaustion> and
L<automatically self-destructs|Automatic Self-Destruction>.

=head3 One Requester, Many Responders

One requester creates many responders, either serially or in a pool to
do work in parallel.

=head4 Serial Responders

In the serial pattern, the requester creates a responder for a single
task and replaces it each time the task completes.  One-shot objects
tend to be used for serial responders.

=head4 Parallel Responders

In the parallel pattern, the requester creates a pool of responders
and optionally replaces each responder as they finish.  The requester
usually owns the objects in the pool.

Parallel responders are often one-shot objects that are replaced
between requests.

Parallel responders may also be multi-shot.  In this case, each
responder may be configured differently to handle a separate class of
requests.  For example, a requester may use multiple HTTP clients,
each configured to connect through a different proxy.

=head3 One Responder, Many Requesters

A persistent or responder is created to do work for many requesters.
The responder is often a service, just as many POE::Component modules
are.

=head3 Many Requesters, Many Responders

This is a combination of the other message transaction patterns.  It's
documented for completeness and as a prompt for more consideration.

=head2 Persistent Inter-Object Channels

I<Todo:> Research and decide on semantics, then syntax.  Look at
Erlang, Haskell and Scala.  Check out various POE publish/subscribe
models, as well as message queues.

=head3 Transactions as Channels

Message transactions may be used as a form of ad hoc channels, but
limitations on when messages may be sent break the metaphor and
introduce potentially burdensome restrictions.  A true persisten
channel would allow entities on either end to send messages without
restriction.

=head2 Connections as Shared Memory

Poetalk is an experimental framework that builds upon Smalltalk
observable members and watchers.  It provides a framework where
objects can watch others' public members.  Watching objects are
automatically notified when these observed members change.  In a
sense, data is shared by message passing along unidirectional
connections.

The framework might mimic this behavior with watchers that can observe
members of other objects.

	$self->{watcher} = Watcher->new(
		object    => $another_object_reference,
		member    => "observable_member_name",
		on_change => "handle_observed_change",
	);

The requirement to use object references limits this pattern to
explicitly managed objects.  However, since watchers are holding
reference, it may be enough to hold references to the watchers.

Care must be taken to avoid circular references.  Heightened
indirection between objects and the code that manages them makes it
easier to lose track of objects.  Ideally the framework should detect
circular references and intelligently weaken key references to avoid
them without releasing objects entirely.

I<Todo:> Develop the semantics and syntax for this mechanism.

I<Todo:> What about objects in remote processes?

=head1 Continuations

Continuations are encapsulated bits of program state that can be
passed around and swapped in and out as needed.  They're used to
bridge the gaps between asynchronous requests and their responses.
They're also used to provide continuity between methods called during
a task.

For example, a continuation is created when a request is made.  This
continuation is associated with the request.  Responses to that
request will include the same continuation.  Client data that belongs
with the reqest may be stored in the request's continuation, and
response handlers will have access to it later.

This illustrates one continuation scenario, but it's not the mechanism
that will be used.  A request is created and given a name.  The
request's continuation is available when the response comes back.

	sub send_request {
		my $self = shift();
		my $request = Request->new();
		$request->{name} = "gorf";
	}

	sub handle_response {
		my ($self, $response) = @_;
		print "This response is to request $response->{name}\n";
	}

Multiple continuations may be active at once.  A continuation may be
created for a subrequest while the parent request's continuation is
active.

Continuations are most often associated with asynchronous requests and
responses.

=head2 Task Continuation

When a service receives a request to perform a task, it's also given a
continuation within which to store temporary state related to that
task.  This I<task continuation> lives in the service until the
request is terminated or completed.

Lexical variables may be aliased into the task continuation.  These
I<task variables> will begin with "task_" to visually differentiate
them from other variables.

Task variables are not shared between objects, even ones that work
together to perform the same task.  Task variables are not shared
between tasks, even ones that are performed by the same object.

	TODO - Example.

Only one task continuation may be active during a method call.  Many
tasks may be performed simultaneously, but a method will only see one
of them at a time.

=head2 Subtask Continuations

Clients may associate continuations with the objects and requests they
create to perform subtasks.  These I<request continuations> live in
their requesting clients until the request is terminated or completed.
Request continuations are available wherever the request or one of its
responses is.

Request continuation members may be aliased to lexical variables whose
names begin with "req_".  This variable prefix is a visual indicator
of the variable's scope and helps prevent collision between
continuations that contain the same members.

Request variables are usually set at the time a request is created,
either using the expose() function or a request's constructor
parameter.

	TODO - Example.

Multiple request continuations may be active while requests are being
created.  However since only one response may be handled at a time,
there may be only one request continuation available in a response
handler.

=head2 Other Magic Variables

Continuations are managed by the Lexical::Persistence module.
Lexical::Persistence may also be used to support additional magic
variables.

=head3 Self Variables

The lexical $self variable may be mapped to the first method
parameter, which is often the object itself.

Variables beginning with "self_" may be aliased to data members within
$self, either directly or via accessors created with Moose.

	sub method {
		my $self_member;      # magic
		my $self->another();  # more magic
	}

=head3 Parameter Variables

Variables beginning with "arg_" may be mapped to members of the second
method parameter, which should always be a hashref of parameter
name/value pairs.  These two methods may be equivalent.

	sub mundane_way {
		my ($self, $args) = @_;
		print "$self called with $args->{name}\n";
	}

	sub magic_way {
		my ($self, $arg_name); # magic
		print "$self called with $arg_name\n";
	}

=head2 Caveats With Contiuations XXX AM HERE XXX

POE::Stage focuses on creating and delivering requests.  It seems to
have some questionable edge cases regarding response handling.
Luckily it's still early in development when these things are free to
change.

POE::Stage provides responders with a continuation representing the
requests they are handling.  These I<request continuations> are
accessed by the req() function among other ways.  Multiple responder
methods can share a request continuation for as long as needed to
formulate a response.

When a response arrives to a requester, it includes access to a
I<response continuation>, accessed by rsp().  Response continuations
are associated with the original requests that triggered the
responses.  Requesters may use response continuations to pass data
back to themselves through requests.

You may notice the metaphor starting to break under the strain of
subjective roles at this point.  Requests have associated response
continuations, and responders receive request continuations.  It's
even difficult to explain clearly.

Finally, when a requester handles a response, it also has req()
available to access the continuation that was active when the request
that triggered the response was created.  I<Todo:> Describe this
better in the morning.

The metaphor breaks down further because responses cannot be
associated with their original requests.  For example, a requester may
wish to destroy a request when it receives the corresponding response.
POE::Stage currently doesn't provide a clean way to tell where the
request lives so that it may be cleaned up.

One way to do this might be to place the location in the response
continuation.

	sub requester_send_request {
		my $self = shift();
		$self->{request_member} = POE::Request->new(...);
		expose $request => my $member_name;
		$member_name = "request_member";
	}

Now the responder can examine rsp()->{member_name} to find out which
$self member to destroy.

	sub handle_response {
		my $self = shift();
		delete $self->{ rsp()->{member_name} };
	}

This should be common enough to warrant a standard mechanism.

=head3 Caveats With Emit and Recall

I<Todo:> Written very late at night.  Consider alternating editorial
passes at the start and middle of the file, so that alertness is
evenly distributed over the document.

Sometimes it's useful to post entirely new requests down an existing
transaction.  This invalidates many aspects of the transaction,
invalidating it.  The issue appeared with an example UDP responder and
its requester, in a 1:1 use pattern.

=over 2

=item * The requester asks the responder to listen on a port.

=item * The responder emits "datagram" messages to the requester.

=item * The requester generates a response, sending it to the responder.

=back

Some prototypical code, assuming that recall() is the method to push
another request down an existing bidirectional connection between two
objects:

	sub handle_datagram {
		my ($self, $args) = @_;

		my $datagram = $args->{datagram};
		$datagram =~ tr[a-zA-Z][n-za-mN-ZA-M];

		$self->{rsp}->recall(
			_method        => "send",
			remote_address => $args->{remote_address},
			datagram       => $datagram,
		);
	}

Some issues to consider:

=over 2

=item *

The request's args will be overwritten by new arguments.  Clobbering
args may be an issue if there are multiple recall()s on the same
rsp().

=item *

Just as emit() creates a new Request (POE::Request::Response), so
should recall().

=item *

The recalled method is called in the context of the req() that
generated the response.  That's rsp() at the time recall() is invoked.

=back

Whatever mechanism is used must be shown to work for arbitrary nesting
of requests and responses.

Response contexts were first needed while writing POE::Stage::Receiver
and the UDP example to use it.  These objjects don't nest arbirarily,
but they do nest a level beyond what was needed to date.  Here's a
synopsis of the interaction between POE::Stage::Receiver and the UDP
example.

=over 2

=item * Consumer requests that the producer listen for datagrams.

The original listen request maps all interesting return types to
methods, including ones like _on_send_error that may never be needed.

	$self->{_udp_peer} = POE::Stage::Receiver->new(...);
	$self->{_udp_req} = POE::Request->new(
		_stage          => $self->{_udp_peer},
		_method         => "listen",
		_on_datagram    => ...,
		_on_recv_error  => ...,   # Handle recv() errors.
		_on_sock_error  => ...,   # Handle socket creation errors.
		_on_send_error  => ...,   # Handle send() errors.
	);

=item * Producer may return a fatal socket error.

	$self->{req}->return(
		_type => "sock_error",
		...,
	);

=item * Producer may emit a nonfatal recv() error.

	$self->{req}->emit(
		_type => "recv_error",
		...,
	);

=item * Producer may return a fatal recv() error.

	$self->{req}->emit(
		_type => "recv_error",
		...,
	);

=item * Producer may emit a datagram.

	$self->{req}->emit(
		_type     => "datagram",
		datagram  => $message,
	);

=item * Consumer recall()s the producer with a response.

Sending a response also specifies a handler for send() errors.

	$self->{rsp}->recall(
		_method         => "send",
		datagram        => $response,
		_on_send_error  => ...,  # Handle send() errors.
	);

The new _on_send_error is evaluated in the same context as the
original one in the first "listen" request.  What is the scope of this
subsequent _on_send_error?

=over 2

=item *

Does it override _on_send_error for the remaining life of the
producer's req?

=item *

Does it override _on_send_error for the lifetime of the send()
method's invocation?

=item *

Does it do something else entirely?

=back

=item * Producer emits a nonfatal send() error.

	$self->{req}->emit(
		_type => "send_error",
		...
	);

=item * Producer returns a fatal send() error.

	$self->{req}->return(
		_type => "send_error",
		...
	);

=back

In light of the preceding evidence, it seems that an arbitrary level
of nesting isn't necessary.  The act of recall()ing a producer pops
off a nesting level, just as emit() or return() do when the responder
calls them.

req() always points up the request tree, into requests made of you.

rsp() always points down, into requests you've made.

At least this is how it works in the current implementation.

=head1 Stages and Actors

Consideration must be given whether to separate POE::Stage from
POE::Actor.  As in the 5.005-threaded POE prototype, it may be useful
to divide a program into multiple I<groups>, each of which may be
running in a separate thread or process.  It makes a certain sense to
call these groups I<stages> in the new design.  Objects themselves may
be considered I<actors> which play their parts in their respective
stages.

I<Todo:> This section is mainly thumbnail outlines.  It requires more
thought and work.

I<Todo:> It doesn't even discuss actors.

=head2 POE::Kernel

POE::Kernel acts as the central dispatcher for cooperative,
single-tasking stages.  As POE events occur, they are dispatched to
their respective stages, which in turn may forward the events to the
appropriate actors.

=head2 Stages

Stages act as sidecar event queues.  Stages forward POE::Kernel events
to actors through means appropriate to the stages' types.

=head3 Cooperative Stages

Cooperative stages act as thin interfaces between POE::Kernel and
actors.  These stages don't really have queues.  They immediately
forward POE::Kernel events to the appropriate actors.

=head3 Threaded Stages

Threaded stages act as bidirectional queues between POE::Kernel (which
lives in the main thread) and the stage that lives in some subthread.
It's quite likely that many things cannot run in threaded stage since
it would require straddling the thread boundary.

For example, it would be difficult (if not impossible) for Tk to
dispatch POE::Kernel events in one thread while creating widgets in
another.

=head3 Forked Stages

It should also be convenient to create actors in child processes.
These actors will also be unable to share resources with POE::Kernel.

=head3 Remote Stages

A program should be able to find an actor on a stage in another
process or on another machine across a network.

=cut
