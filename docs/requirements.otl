[_] 32% Framework Requirements
	About
		This document summarizes the best ideas from the patterns document.
		The patterns document tries to enumerate all available options.
		The requirements document chooses which ones to actually use.
		A later specification document will attempt to reconcile the requirements into a syntax and semantics.
	Desirable Qualities
		Best practices should be encouraged.
			Base classes should set precedents for best practices.
			The design should encourage continued use of best practices.
		Substandard qualities should be possible but gently discouraged.
			People like to have options.
			People like to exercise those options, whether or not they're good.
			It's not the framework's duty to prevent people from doing what they want.
	Undesirable Qualities
		Avoid implicit constructs.
			Implicit constructs cause action without visible indication.
			They are disorienting.
			They interfere with comprehension.
		Avoid unnecessary magic.
			Magic is scary.
			It also implies action at a distance.
		Avoid cleverness.
			Cleverness leads to brittle design.
			It also leads to unnecessary magic.
			It also leads to implicit constructs.
		Avoid metaphors.
			Metaphors are harmful when writing abstract frameworks.
			Metaphors are useful tools for creating systems that mimic real things.
				When designed properly, metaphors provide conceptual and contextual information about a framework.
			Metaphors are contradictory to abstract design.
				Metaphors provide specific conceptual frameworks.
				System designs that fit within these frameworks are elegant.
				Systems that wish to use other concepts are generally awkward.
				Adapters can connect between metaphors, but they should not be needed.
	[_] 0% Namespace Requirements
		[_] 0% Choose a short base name for the namespace.
			Large class names are unwieldy.
			Objects should be under a single top-level namespace.
				What single top-level namespace should be used?
		[_] 0% Choose a relatively flat namespace for the framework.
			Excessive namespace nesting is unwieldy.
			The namespace should be organized.
			How should the namespace be organized?
	[_] 12% Class and Object Structural Requirements
		[_] 50% Support full object orientation.
			[X] 100% Support composition of smaller objects into larger ones (has-a).
			[X] 100% Support composition through direct inheritance.
			[_] 0% Support composition through class roles.
			[_] 0% Support composition through runtime object roles.
		[_] 0% Method parameters should follow a single standard.
			[_] 0% Methods should receive only two parameters.
				$self - The object being called.
				$args - A hash reference of named parameter pairs.
				[_] 0% What about out-of-band information, such as other continuations?
			[_] 0% Methods should standardize their return semantics.
				What are those semantics?
				Returned messages must be typed.
		[_] 0% Function parameters should follow a single standard.
			[_] 0% What should that standard be?
		[_] 0% Procedural design should be supported.
			Some people will prefer procedural design.
	[_] 66% Object Containership Composition Rules
		[X] 100% Containership rules are delegated to the objects themselves.
		[X] 100% Contained objects may be assigned roles.
			Roles identify contained objects by non-unique names.
			Default handler method names may be derived from roles and message types.
				Sender is a DNS resolver.
				Sender's role is "resolver".
				Sender emits a "success" event.
				Container may define an on_resolver_success() method to handle the event.
		[_] 0% Methods
			[_] 0% insert
			[_] 0% remove
			[_] 0% find
	[X] 100% Class Inheritance Rules
		[X] 100% Class inheritance rules are delegated to Moose.
	[_] 19% Messaging Requirements
		[_] 0% Object command interfaces must be objects.
			[_] 0% Methods on the objects themselves may pass messages into themselves.
				Synchronous method calls are translated into asynchronous messages.
			[_] 0% Methods on the objects may trigger activity that emits new events.
				Synchronous actions may start or stop messages emitted by an object.
			[_] 0% Objects may be interfaces (proxies) that pass messages to other objects.
				Objects may act as interfaces to local or remote services.
				Synchronous method calls are translated into asynchronous messages.
		[_] 0% Local accessors and simple mutators must be synchronous.
			Messages for local accessors and mutators is unnecessary overhead.
		[_] 22% Objects must be permitted to emit messages into their containers.
			[_] 0% Message emission is optional, depending on the use case.
				[_] 0% Define a use case where message emission is required.
				[_] 0% Define a use case where it's not.
			[_] 66% Emitted messages are first handled by the object emitting them.
				[X] 100% Subclasses may handle messages emitted by base classes.
				[X] 100% Subclasses may emit new messages.
				[_] 0% Subclasses may emit the same message without re-catching it.
			[_] 0% Emitted messages are next handled by explicit and role-based observers.
		[_] 75% All forms of message handler must be supported.
			[X] 100% Anonymous Coderefs
				Anonymous coderefs support closures.
				Anonymous coderefs and closures may be used to implement faux continuation passing style.
			[X] 100% Named Subroutine References
				Named message handlers are exportable as reusable interfaces.
			[X] 100% Object Methods
				Is this not obvious?
			[_] 0% Class Methods
				Classes may be used as singletons.
		[_] 0% Messages must be associated with their triggers.
			[_] 0% One message may trigger another, inner message.
				[_] 0% The inner message must be associated with the outer message.
				[_] 0% Canceling the outer message must trigger cancelation of all associated inner messages.
				[_] 0% Generally, all inner messages should complete before an outer message completes.
					This emulates asynchronous call/return semantics for messages.
					Task coordination is simplified.
	[_] % Session Location Rules
		[_] % Objects may be created in the same session as the creator.
		[_] % Objects may be created in new sessions, separate from the creator.
			[_] % New sessions may be started in the same process as the previous one.
			[_] % New sessions may be started in new threads.
			[_] % New sessions may be started in other processes.
				[_] % Processes may be forked at session creation time.
				[_] % Processes may be already established and attached to.
	[_] 0% Continuation Rules
		[_] 0% Continuations may be associated with objects.
			$self is such a continuation.
			[_] 0% Object-scoped resources (watchers, etc) should be stored in the object's continuation.
				[_] 0% Object destruction triggers associated resource cleanup.
		[_] 0% Continuations may be associated with messages.
			[_] 0% A message's sender and receiver may have their own continuations associated with the message.
			[_] 0% Data stored in the sender's continuation is not visible to the receiver.
			[_] 0% Receiver data is not visible to the sender.
			[_] 0% Message-scoped resources should be stored in the message's continuation.
				[_] 0% Message cancelation triggers associated resource cleanup.
	[_] 33% Common primitive classes must be provided.
		[_] 50% Low-level event watchers.
			[X] 100% I/O
				[X] 100% Handle
			[_] 50% Time 
				[_] 0% Alarm
				[X] 100% Delay
			[_] 0% Signals
				[_] 0% Signal
			What else?
		[_] 16% Primitive program pieces.
			[_] 0% Application
			[_] 0% Server
			[_] 0% Stream
			[_] 0% Process
			[X] 100% UdpPeer
			[_] 0% What else?  Probably a lot!
