$Id$

It's very difficult to grow an object environment from basic
principles.  The rules eventually reach a point where new extensions
don't work, and the cause is usually some fundamental rule that hasn't
anticipated everything in advance.

So I'm never getting anywhere if I don't document some use patterns.

Providers and consumers.

	Providers and consumers are things on either side of a transaction.
	A provider is usually a component, and a consumer is usually a
	session that requires something from the component.

	Consumers can also be components, in the case where one component
	needs a service from another.  POE::Component::Client::HTTP is a
	consumer of POE::Component::Client::DNS services.

Provider/consumer relationships.

	One provider, one consumer.

		The consumer has created a provider for its exclusive use.

		POE::Wheel classes are built for this type of pattern.  A Wheel
		instance acts as a provider for a single Session (its creator).
		Many POE::Component::IRC use cases also follow this pattern: An
		IRC bot instance creates and interacts with a single IRC
		connection instance.

		I'm temporarily ignoring the case where a POE::Session has more
		than one POE::Wheel.

		One solution to the 1:1 relationship is to subclass the provider
		with consumer features.  This sounds extremely convenient for
		small, quick programs.

		In the 1:1 case, an object may use $self for its context rather
		than some request or transaction.  This is impractical, however,
		since the object can't tell the number of consumers it will handle
		ahead of time.
		
		Therefore the contextual mechanism should be the same as
		one-provider/many-consumers, even in the one-provider/one-consumer
		mode.

	One provider, many consumers.

		Consumers make transactional requests of the provider.  The
		provider maintains a separate request context for each consumer
		with a pending request.

		POE::Component::Client::DNS and Client::HTTP follow this pattern.
		A single component instance provides responses to one or more
		concurrent consumers.

	Many providers, one consumer.

		A consumer creates instances of many providers and talks to them
		in parallel.  For example, an IRC bot that bounces mesages between
		two servers would be implemented as a single bot Session and two
		POE::Component::IRC sessions.  Messages that arrive from one IRC
		session are bounced to the other.

		Each provider can use its instance as a context since it will only
		interact with one consumer.

		The consumer can address individual providers because it has
		instances of each.  Something third-sortie POE::Stage does not
		address, however, is a method for determining which provider sent
		it a message.  This becomes an issue when a single consumer holds
		multiple instances of the same type of provider.  Which provider
		sent a message of type X?

	Many providers, many consumers.

		Consumers and providers should be prepared for many/many
		situations by default.

		Each provider must keep transactional requests to differentiate
		between consumers.

		Consumers make transactional requests, holding onto transaction
		objects until they're no longer needed.

Stage lifetimes.

	The Stage lives to handle a single request.

		Create a Stage.
		Create the Request for it.
		Upon completion of the Request, destroy the Stage.

		What existing POE::Components do this?

		This would be expensive if POE::Stage objects mapped one-to-one to
		POE::Session instances.

	The Stage lives to handle many requests.

		Create a Stage.
		Create several Requests for it.
		Keep the Stage around to handle them all.

		Most POE::Components do this, but maybe it's an artifact of
		POE::Session creation and destruction being relatively
		heavyweight.  The pressure to reuse components would ease in
		POE::Stage, as creating and destroying them isn't nearly as
		expensive.

Requests as channels or connections.

	Requests are similar to connections between objects.  The owner and
	receiver are in a dialog as long as the request remains active.

  Third-sortie POE::Stage focused on creating requests and ferrying
	them to their receivers.  It didn't anticipate the issues and
	semantics of receiving responses and dealing with them.

	The current context has a member, _req.  It identifies the request
	that is a parent of the current context.

	Now there is also a _rsp object, but it is not useful in this
	situation.  _rsp is either the Emit object or 0 in the case of a
	Request object.

	What's needed is a third field that identifies the request object
	that is the parent of the _rsp.  This third field would be the
	original request that the current stage sent.  Call it _moo for want
	of a better name.

	This would still leave a disconnect between _moo and the contextual
	member a program stored the main response in.

	For example:

	  $self->{_some_request} = POE::Request->new(...);

	Receiving a response from _some_request sets _moo = $request_object.
	There still is no conventient way to determine that $self->{_moo}
	represents the request in $self->{_some_request}.  To be sure, they
	are equal, but it's inconvenient to determine which member to delete
	when ending a request:

	  sub handle_response {
			my ($self, $args) = @_;
			my $responding_request = $self->{_moo};

			# How do I know to delete $self->{_some_request} vs. any of
			# the arbitrary other requests I may be holding?
		}
	
	$self is a magical tied hash thing.  It could cross-reference
	request references to the members stored in them:

		sub STORE {
			my ($self, $key, $value) = @_;

			if (ref($value) and blessed($value) and $value->isa("POE::Request")) {
				$self->[XREF]{$value}{$key} = 1;
			}

			...;
		}

	Caveat: This only tracks cross-references when POE::Request objects
	are stored as simple scalars.  Hiding them in complex structures
	will thwart cross-referencing.

	Now it's possible for a Stage to connect _moo to the original
	member(s) where the response is stored:

		sub destroy_request {
			my ($self, $request) = @_;
			my @members = $self->_find_member_names($request);
			delete @$self{@members};
		}

Re-triggering existing requests.

	DONE.

	We also need a way to post new requests down the old request.  I
	think this invalidates the idea of a "request" since it changes the
	original request context, losing any original data that might still
	be worked on.
	
	The issue I'm seeing is with a UDP producer and its consumer, in a
	more-or-less 1:1 use pattern.
	
		1. The consumer asks the producer to listen on a port.

		2. The producer emits a "datagram" message to the consumer.

		3. The consumer generates a response, sending it to the producer.

	Some prototypical code:

		sub handle_datagram {
			my ($self, $args) = @_;

			my $datagram = $args->{datagram};
			$datagram =~ tr[a-zA-Z][n-za-mN-ZA-M];

			$self->{_rsp}->recall(
				_method        => "send",
				remote_address => $args->{remote_address},
				datagram       => $datagram,
			);
		}
	
	This assumes recall() is the method to push another method call into
	the same request context that generated a response.  Some issues to
	consider:

		The request's _args will be overwritten by new arguments.  This
		may be an issue if there are multiple recall()s on the same _rsp.
		Why?  Subsequent recall()s overwrite previous ones' _args.

		Just as emit() creates a new Request (POE::Request::Response), so
		should recall().

		The recalled method is called in the context of the _req that
		generated the response.  That's _rsp at the time recall() is
		invoked.

	Will this work for arbitrary nesting of requests and responses?  For
	example, what if a producer wants to respond to a response to a
	response?

	I first noticed a need for response contexts while writing the
	Receiver stage and UDP example to use it.  They don't nest
	arbitrarily, but they do nest a level beyond what I had needed so
	far.  Here's a synopsis of the interaction between the UDP example
	and POE::Stage::Receiver.

		1. Consumer requests that the producer listen for datagrams.

			$self->{_udp_peer} = POE::Stage::Receiver->new(...);
			$self->{_udp_req} = POE::Request->new(
				_stage          => $self->{_udp_peer},
				_method         => "listen",
				_on_datagram    => ...,
				_on_recv_error  => ...,   # Handle recv() errors.
				_on_sock_error  => ...,   # Handle socket creation errors.
				_on_send_error  => ...,   # Handle send() errors.
			);

			Note: The original listen request maps all interesting return
			types to methods, including ones like _on_send_error that may
			never be needed.

		2. Producer may return a fatal socket error.

			$self->{_req}->return(
				_type => "sock_error",
				...,
			);

		3a. Producer may emit a nonfatal recv() error.

			$self->{_req}->emit(
				_type => "recv_error",
				...,
			);

		3b. Producer may return a fatal recv() error.

			$self->{_req}->emit(
				_type => "recv_error",
				...,
			);

		3c. Producer may emit a datagram.

			$self->{_req}->emit(
				_type     => "datagram",
				datagram  => $message,
			);

		4. Consumer recall()s the producer with a response.

			$self->{_rsp}->recall(
				_method         => "send",
				datagram        => $response,
				_on_send_error  => ...,  # Handle send() errors.
			);

			Note: Sending a response also specifies a handler for send()
			errors.

			TODO:

				The new _on_send_error is evaluated in the same context as the
				original one in the first "listen" request.  What is the scope
				of this subsequent _on_send_error?

				a. Does it override _on_send_error for the remaining life of
				the producer's _req?

				b. Does it override _on_send_error for the lifetime of the
				send() method's invocation?

				c. Does it do something else entirely?

		5a. Producer emits a nonfatal send() error.

			$self->{_req}->emit(
				_type => "send_error",
				...
			);

		5b. Producer returns a fatal send() error.

			$self->{_req}->return(
				_type => "send_error",
				...
			);

	It seems like we don't need an arbitrary level of nesting.  The act
	of recall()ing a producer pops off a nesting level, just as emit()
	or return() do when the producer calls them.

	_req always points up the request tree, into requests made of you.

	_rsp always points down, into requests you've made.

Connections as shared memory.

	The poetalk project implemented a different type of connection
	between objects.  Its connections were essentially shared data
	members.  A producer defines a data member.  Zero or more consumers
	watch the data member.  Consumers are notified when the data they're
	watching are modified.

	An object in poecall can watch its own data members, triggering
	methods when watched data changes.

	POE::Stage and POE::Request might mimic this behavior with one new
	facility:  Allow one object to watch another's data.  This can be
	simulated with a regular request and some code in the base
	POE::Stage class.
	
	One object requests notification when another object changes a data
	member.

		$self->{_foo_watcher} = POE::Request->new(
			_stage      => $some_object,      # The object to watch.
			_method     => "watch",           # I'm watching you!
			member      => "foo",             # This is what I'm watching.
			_on_change  => "catch_change",    # Call my method on change.
		);

	Now my catch_change() method will be called when the remote object
	changes its "foo" data member.

	POE::Stage requires a watch() method to record which requests are
	watching certain data members.  When those members change, it can
	emit responses to the associated requests.

	There is a subtle issue when watching context-scoped data.  That's
	because _foo is scoped beneath the request that watches it.  The
	watcher will not notice changes to _foo in any other request
	context.

	Todo: Make a sample program where this works.  That would be SO
	cool!

Catching emitted and returned data.

	The next pattern to consider is what to do with emitted and returned
	data once it's caught.  In POE components, one keeps track of
	requests in a couple ways.

		1. Pass all the data about the request down with the request
		event.  Responses include the request data when they come back.
		Caveat: If they don't come back, you forget you made the request.

		2. Save the request data keyed on a request handle.  When the
		response comes back, its copy of the request handle is used to
		look up the original request data.

	Both methods seem like more work than necessary.

	Stages currently have two kinds of scope:

		$self->{unadorned_member}.  Members without a leading underscore
		are associated with the stage's instance.  They are accessible
		from every request made of the stage.

		$self->{_single_underscore}.  Members with a single leading
		underscore are associated with the current request being made of a
		stage.  POE::Stage always makes sure that single-underscored
		members point to the proper request.

	My current thought on this is to create a third scope in $self that
	associates data with requests made by the current stage.  I'll call
	this a sub-request scope, since it applies to a request made during
	a request.
	
	The scope would be active in two places:

		1. It would start when a request is created, and it would end when
		another request was created (which starts a new scope), or when
		the current method ended.

		2. It would start when a method is called to handle a response,
		and it would end when another request was created (which starts a
		new scope), or when the current method ended.

	Both cases are problematic, but I'll address #2 first because it's
	worse.  Creating a new request invalidates the response's scope,
	which is probably not desirable.  Programs can work around the
	problem by extracting data from the current sub-request scope before
	creating new ones:

		my $x = $self->{__x};
		my $y = $self->{__y};
		etc.

	I hate this.  It feels forced and ugly.

	The first situation has a similar problem.  Creating new sub-request
	scopes invalidates previous ones, and it's not always apparent
	what's going on.  For example, rearranging code can silently move
	data to different scopes.  This WILL bite someone, probably sooner
	than later.

	An obvious solution is to key data members on request objects.  My
	design test case is a parallel log resolver that juggles a number of
	parallel requests to a hypothetical POE::Stage::Resolver:

		sub run {
			my ($self, $args) = @_;
			open $self->{_log}, "<$args->{input_file}" or die $!;
			$self->{_resolver} = POE::Stage::Resolver->new();
			$self->start_requests();
		}

		sub start_requests {
			my ($self, $args) = @_;

			while ($self->{_request_count} < 10) {
				my $log = $self->{_log};
				my $next_line = <$log>;
				return unless $next_line;

				my $address = $next_line =~ /^(\d+\.\d+\.\d+\.\d+) /;
				next unless $address;

				my $request = POE::Request->new(
					_stage => $self->{_resolver},
					_method => "resolve",
					address => $address,
					type    => "PTR",
					_on_ptr => "handle_ptr",
				);

	Here we're tracking the subrequest beneath a request.

				$self->{_requests}{$request} = {
					addr => $address,
					line => $next_line,
				};
			}
		}

		sub handle_ptr {
			my ($self, $args) = @_;

			my $request = some_magic_here();
			my $req_rec = delete $self->{_requests}{$request};

	Here we have access to $req_rec->{addr} and "line".

		}

	This STILL seems like excessive effort, but it does have the benefit
	of being explicit.

	The double-underscore version would look something like this:

		sub start_requests {
			my ($self, $args) = @_;

	Up here, $self->{__moo} refers to the moo member of the request
	we're currently servicing.

			while ($self->{_request_count} < 10) {
				...;

				my $request = POE::Request->new(
					_stage => $self->{_resolver},
					_method => "resolve",
					address => $address,
					type    => "PTR",
					_on_ptr => "handle_ptr",
				);

	Here __addr and __line (and __moo, if we chose to use it) are
	associated with the request we built just above.  At this point we
	cannot access the original __moo given to us.

				$self->{__addr} = $address;
				$self->{__line} = $next_line;
			}
		}

		sub handle_ptr {
			my ($self, $args) = @_;

	We have magic access to $self->{__addr} and __line here.
	I think this is pretty nice, actually.

		}

	A combination of the two might be better.  How about these two
	rules:

		1. At sub-request creation time, certain conventions are used to
		store requests and associated data.

			Todo: Determine some sexy syntax.

		2. At sub-request return/emit time, the doubly-adorned member
		syntax refers to the request returning or emitting a value.  New
		sub-requests follow rule #1, so they don't conflict with our
		doubly-adorned members.
