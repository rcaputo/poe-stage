$Id$

It's very difficult to grow an object environment from basic
principles.  The rules eventually reach a point where new extensions
don't work, and the cause is usually some fundamental rule that hasn't
anticipated everything in advance.

So I'm never getting anywhere if I don't document some use patterns.

Providers and consumers.

	Providers and consumers are things on either side of a transaction.
	A provider is usually a component, and a consumer is usually a
	session that requires something from the component.

	Consumers can also be components, in the case where one component
	needs a service from another.  POE::Component::Client::HTTP is a
	consumer of POE::Component::Client::DNS services.

Provider/consumer relationships.

	One provider, one consumer.

		The consumer has created a provider for its exclusive use.

		POE::Wheel classes are built for this type of pattern.  A Wheel
		instance acts as a provider for a single Session (its creator).
		Many POE::Component::IRC use cases also follow this pattern: An
		IRC bot instance creates and interacts with a single IRC
		connection instance.

		I'm temporarily ignoring the case where a POE::Session has more
		than one POE::Wheel.

		One solution to the 1:1 relationship is to subclass the provider
		with consumer features.  This sounds extremely convenient for
		small, quick programs.

		In the 1:1 case, an object may use $self for its context rather
		than some request or transaction.  This is impractical, however,
		since the object can't tell the number of consumers it will handle
		ahead of time.
		
		Therefore the contextual mechanism should be the same as
		one-provider/many-consumers, even in the one-provider/one-consumer
		mode.

	One provider, many consumers.

		Consumers make transactional requests of the provider.  The
		provider maintains a separate request context for each consumer
		with a pending request.

		POE::Component::Client::DNS and Client::HTTP follow this pattern.
		A single component instance provides responses to one or more
		concurrent consumers.

	Many providers, one consumer.

		A consumer creates instances of many providers and talks to them
		in parallel.  For example, an IRC bot that bounces mesages between
		two servers would be implemented as a single bot Session and two
		POE::Component::IRC sessions.  Messages that arrive from one IRC
		session are bounced to the other.

		Each provider can use its instance as a context since it will only
		interact with one consumer.

		The consumer can address individual providers because it has
		instances of each.  Something third-sortie POE::Stage does not
		address, however, is a method for determining which provider sent
		it a message.  This becomes an issue when a single consumer holds
		multiple instances of the same type of provider.  Which provider
		sent a message of type X?

	Many providers, many consumers.

		Consumers and providers should be prepared for many/many
		situations by default.

		Each provider must keep transactional requests to differentiate
		between consumers.

		Consumers make transactional requests, holding onto transaction
		objects until they're no longer needed.

Stage lifetimes.

	The Stage lives to handle a single request.

		Create a Stage.
		Create the Request for it.
		Upon completion of the Request, destroy the Stage.

		What existing POE::Components do this?

		This would be expensive if POE::Stage objects mapped one-to-one to
		POE::Session instances.

	The Stage lives to handle many requests.

		Create a Stage.
		Create several Requests for it.
		Keep the Stage around to handle them all.

		Most POE::Components do this, but maybe it's an artifact of
		POE::Session creation and destruction being relatively
		heavyweight.  The pressure to reuse components would ease in
		POE::Stage, as creating and destroying them isn't nearly as
		expensive.

Requests as channels or connections.

	Requests are similar to connections between objects.  The owner and
	receiver are in a dialog as long as the request remains active.

  Third-sortie POE::Stage focused on creating requests and ferrying
	them to their receivers.  It didn't anticipate the issues and
	semantics of receiving responses and dealing with them.

	The current context has a member, _req.  It identifies the request
	that is a parent of the current context.

	Perhaps what's needed is a new special member, _rsp or something,
	that identifies the request that is the parent of a response.  This
	would still leave a disconnect between _rsp and the contextual
	member a program stored the main response in.

	For example:

	  $self->{_some_request} = POE::Request->new(...);

	Receiving a response from _some_request sets _rsp = $request_object.
	There still is no conventient way to determine that $self->{_rsp}
	represents the request in $self->{_some_request}.  To be sure, they
	are equal, but it's inconvenient to determine which member to delete
	when ending a request:

	  sub handle_response {
			my ($self, $args) = @_;
			my $responding_request = $self->{_rsp};

			... How do I know to delete $self->{_some_request} vs. any of
			the arbitrary other requests I may be holding?
		}
	
	$self is a magical tied hash thing.  It could cross-reference
	request references to the members stored in them:

		sub STORE {
			my ($self, $key, $value) = @_;

			if (ref($value) and blessed($value) and $value->isa("POE::Request")) {
				$self->[XREF]{$value}{$key} = 1;
			}

			...;
		}

	Caveat: This only tracks cross-references when POE::Request objects
	are stode as simple scalars.  Hiding them in complex data structures
	will thwart cross-referencing.

	Now it's possible for a Stage to connect _rsp to the original
	member(s) where the response is stored:

		sub destroy_request {
			my ($self, $request) = @_;
			my @members = $self->_find_member_names($request);
			delete @$self{@members};
		}

	We also need a way to post new requests down the old request.  I
	think this invalidates the idea of a "request" since it changes the
	original request context, losing any original data that might still
	be worked on.
	
	The issue I'm seeing is with a UDP producer and its consumer, in a
	more-or-less 1:1 use pattern.
	
		1. The consumer asks the producer to listen on a port.

		2. The producer emits a "datagram" message to the consumer.

		3. The consumer generates a response, sending it to the producer.

	Some prototypical code:

		sub handle_datagram {
			my ($self, $args) = @_;

			my $datagram = $args->{datagram};
			$datagram =~ tr[a-zA-Z][n-za-mN-ZA-M];

			$self->{_rsp}->recall(
				_method        => "send",
				remote_address => $args->{remote_address},
				datagram       => $datagram,
			);
		}
	
	This assumes recall() is the method to push another method call into
	the same request context that generated a response.  Some issues to
	consider:

		The request's _args will be overwritten by new arguments.  This
		may be an issue if there are multiple recall()s on the same _rsp.
		Why?  Subsequent recall()s overwrite previous ones' _args.

		Just as emit() creates a new Request (POE::Request::Response), so
		should recall().

			TODO: It would be tidily symmetrical if one could call
			$self->{_rsp}->emit() rather than recall().  Test whether one
			can.

		The recalled method is called in the context of the _req that
		generated the response.  That's _rsp at the time recall() is
		invoked.

	Will this work for arbitrary nesting of requests and responses?  For
	example, what if a producer wants to respond to a response to a
	response?

	I first noticed a need for response contexts while writing the
	Receiver stage and UDP example to use it.  They don't nest
	arbitrarily, but they do nest a level beyond what I had needed so
	far.  Here's a synopsis of the interaction between the UDP example
	and POE::Stage::Receiver.

		1. Consumer requests that the producer listen for datagrams.

			$self->{_udp_peer} = POE::Stage::Receiver->new(...);
			$self->{_udp_req} = POE::Request->new(
				_stage          => $self->{_udp_peer},
				_method         => "listen",
				_on_datagram    => ...,
				_on_recv_error  => ...,   # Handle recv() errors.
				_on_sock_error  => ...,   # Handle socket creation errors.
				_on_send_error  => ...,   # Handle send() errors.
			);

			Note: The original listen request maps all interesting return
			types to methods, including ones like _on_send_error that may
			never be needed.

		2. Producer may return a fatal socket error.

			$self->{_req}->return(
				_type => "sock_error",
				...,
			);

		3a. Producer may emit a nonfatal recv() error.

			$self->{_req}->emit(
				_type => "recv_error",
				...,
			);

		3b. Producer may return a fatal recv() error.

			$self->{_req}->emit(
				_type => "recv_error",
				...,
			);

		3c. Producer may emit a datagram.

			$self->{_req}->emit(
				_type     => "datagram",
				datagram  => $message,
			);

		4. Consumer generates a datagram in response.

			$self->{_rsp}->recall(
				_method         => "send",
				datagram        => $response,
				_on_send_error  => ...,  # Handle send() errors.
			);

			Note: Sending a response also specifies a handler for send()
			errors.

			TODO:

				The new _on_send_error is evaluated in the same context as the
				original one in the first "listen" request.  What is the scope
				of this subsequent _on_send_error?

				a. Does it override _on_send_error for the remaining life of
				the producer's _req?

				b. Does it override _on_send_error for the lifetime of the
				send() method's invocation?

				c. Does it do something else entirely?

		5a. Producer emits a nonfatal send() error.

			$self->{_req}->emit(
				_type => "send_error",
				...
			);

		5b. Producer returns a fatal send() error.

			$self->{_req}->return(
				_type => "send_error",
				...
			);

	It seems like we don't need an arbitrary level of nesting.  The act
	of recall()ing a producer pops off a nesting level, just as emit()
	or return() do when the producer calls them.

Connections as shared memory.

	The poetalk project implemented a different type of connection
	between objects.  Its connections were essentially shared data
	members.  A producer defines a data member.  Zero or more consumers
	watch the data member.  Consumers are notified when the data they're
	watching are modified.

	An object in poecall can watch its own data members, triggering
	methods when watched data changes.

	POE::Stage and POE::Request might mimic this behavior with one new
	facility:  Allow one object to watch another's data.  This can be
	simulated with a regular request and some code in the base
	POE::Stage class.
	
	One object requests notification when another object changes a data
	member.

		$self->{_foo_watcher} = POE::Request->new(
			_stage      => $some_object,      # The object to watch.
			_method     => "watch",           # I'm watching you!
			member      => "foo",             # This is what I'm watching.
			_on_change  => "catch_change",    # Call my method on change.
		);

	Now my catch_change() method will be called when the remote object
	changes its "foo" data member.

	POE::Stage requires a watch() method to record which requests are
	watching certain data members.  When those members change, it can
	emit responses to the associated requests.

	There is a subtle issue when watching context-scoped data.  That's
	because _foo is scoped beneath the request that watches it.  The
	watcher will not notice changes to _foo in any other request
	context.
